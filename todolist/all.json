{
	"success": true,
	"data": [{
		"id": "58d0fb3517f61387400b7e15",
		"author_id": "4f447c2f0a8abae26e01b27d",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png\" alt=\"screenshot.png\"></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/25860846\">https://zhuanlan.zhihu.com/p/25860846</a></p>\n</blockquote>\n<hr>\n<p>时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。</p>\n<ul>\n<li>官网传送门：<a href=\"https://eggjs.org\">https://eggjs.org</a></li>\n<li>GitHub：<a href=\"https://github.com/eggjs/egg\">https://github.com/eggjs/egg</a></li>\n<li>Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(<a href=\"mailto:1030041592@qq.com\">1030041592@qq.com</a>)。期待你的加入！</li>\n</ul>\n<h2>特点</h2>\n<ul>\n<li><strong>『企业级的 Node.js Web 基础框架』</strong>，寓意 - 孕育新生。</li>\n<li>业界领先的 <strong>『微内核 + 插件机制』</strong>，专为团队架构师量身打造的 <strong>『框架定制』</strong> 能力。</li>\n<li>内建的安全机制与多进程管理模型。</li>\n<li>高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。</li>\n<li>同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。</li>\n<li>沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。</li>\n<li>渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。</li>\n</ul>\n<h2>里程碑</h2>\n<ul>\n<li>2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。</li>\n<li>2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。</li>\n<li>2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。</li>\n<li>2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。</li>\n<li>2016 年 09 月，在 <a href=\"http://2016.jsconf.cn/\">JSConf China 2016</a> 上亮相并宣布开源。</li>\n<li>2017 年初，经过一周的<a href=\"https://cnodejs.org/topic/5870e9da04dcf9a706a745f0\">闭关直播写文档</a>，期待已久的 <a href=\"https://eggjs.org/\">官方文档</a> 诚意登场，足足近 30 篇。</li>\n<li>2017年 02 月，知乎问答：<a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></li>\n<li>2017 年 02 月第 2 周，上了 <strong>GitHub Trending</strong> 周榜第三，Star 数增加 1k 多。</li>\n<li>2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。</li>\n</ul>\n<h2>成就</h2>\n<ul>\n<li>截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。</li>\n<li>GitHub Trending 周榜第三，并上了 Node Weekly 周刊。</li>\n<li>官网 UV 日均 300+ 。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png\" alt=\"screenshot.png\"></p>\n<ul>\n<li>Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png\" alt=\"screenshot.png\"></p>\n<h2>感言</h2>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png\" alt=\"screenshot.png\"></p>\n<h2>规划</h2>\n<ul>\n<li>Egg.js 英文文档翻译，欢迎加入 <a href=\"http://swift.gg/\">SwiftGG 翻译组</a> 发起的 <a href=\"https://github.com/eggjs/egg/issues/363\">Egg 文档翻译项目</a>。</li>\n<li>继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。</li>\n<li>Node.js 8 LTS 发布后，底层将无缝升级到 Koa<a href=\"/user/2\">@2</a> 。</li>\n</ul>\n</div>",
		"title": "Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架",
		"last_reply_at": "2017-04-01T03:55:35.253Z",
		"good": false,
		"top": true,
		"reply_count": 71,
		"visit_count": 4627,
		"create_at": "2017-03-21T10:06:45.487Z",
		"author": {
			"loginname": "atian25",
			"avatar_url": "https://avatars.githubusercontent.com/u/227713?v=3&s=120"
		}
	}, {
		"id": "58ad76db7872ea0864fedfcc",
		"author_id": "51f0f267f4963ade0e08f503",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md\">阅读更多</a></p>\n<h2>整理中的专题</h2>\n<ul>\n<li>存储</li>\n<li>安全</li>\n</ul>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>",
		"title": "饿了么大前端 Node.js 进阶教程",
		"last_reply_at": "2017-04-01T02:18:52.084Z",
		"good": true,
		"top": true,
		"reply_count": 97,
		"visit_count": 17453,
		"create_at": "2017-02-22T11:32:43.547Z",
		"author": {
			"loginname": "lellansin",
			"avatar_url": "https://avatars1.githubusercontent.com/u/2081487?v=3&s=120"
		}
	}, {
		"id": "57ea257b3670ca3f44c5beb6",
		"author_id": "541bf9b9ad60405c1f151a03",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>写在头部</p>\n</blockquote>\n<p>本项目写于小程序发布之初，期间小程序官方有过几次更新，例如准备移除了loading组件、改变page的默认高度等，主要看的还是博卡君的文章，后来在朋友的建议下在9月27号写了本篇文章并分享到github上，是做为微信小应用的入门教程，<strong>并非某在线学习网站499收费课程的作业</strong>，特此声明。</p>\n<blockquote>\n<p>微信应用号入门实践之cnode社区版</p>\n</blockquote>\n<p>首先感谢cnode社区提供的api，本次实现了简单的cnode社区应用号制作。\n实现了数据的读取、展示，\n实现了简单的布局，\n实现了下一页功能。</p>\n<p>放上我的github地址\n<a href=\"https://github.com/coolfishstudio/wechat-webapp-cnode\">https://github.com/coolfishstudio/wechat-webapp-cnode</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Fo4zG2Vfe50352POPZYXv8Ls0Jcc\" alt=\"首页列表\">\n<img src=\"//dn-cnode.qbox.me/Fl7TiaW13s541lHZ7Crq7NxKshqG\" alt=\"内容详情\"></p>\n<p>下面就说说我做这个的过程，不足之处，请多多指教，只愿为进步。</p>\n<h2>1.创建项目</h2>\n<p>首先，在官网下载工具，<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214\">下载地址</a> 我的是选择mac版本0.9.092300。</p>\n<p>然后跟着官方的<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1474887501301\">简版教程</a> 创建一个项目。</p>\n<h4>注：现在官方的工具支持无appid创建项目。</h4>\n<h5>1.打开开发者工具，选择“添加项目”</h5>\n<p><img src=\"//dn-cnode.qbox.me/FsqxRNIzNDyzItbl-vhAFPr0J5t2\" alt></p>\n<h5>2.选择无appid，填写地址，创建项目</h5>\n<p><img src=\"//dn-cnode.qbox.me/Fp098WRAyxgJ415Dt_f0YGhjIMHr\" alt></p>\n<h5>3.创建成功，看到默认的Demo项目页面</h5>\n<p><img src=\"//dn-cnode.qbox.me/FuvUmKfcUu8MeLc4eeuwNBfkbfMC\" alt></p>\n<h2>2.配置</h2>\n<p>默认的项目里已经没有关于tabBar的配置信息，所以为了学习，我把这个配置进行了修改。</p>\n<p>首先关于配置的说明同样来自于<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=1474887501556\">官方</a></p>\n<p>注意：官方的代码有些字段是不一样的，小心被坑。</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;pages&quot;:[\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;\n  ],\n  &quot;window&quot;:{\n    &quot;backgroundTextStyle&quot;:&quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,\n    &quot;navigationBarTextStyle&quot;:&quot;black&quot;\n  },\n  &quot;tabBar&quot;:{\n    &quot;list&quot;: [{\n      &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;: &quot;首页&quot;\n    }, {\n      &quot;pagePath&quot;: &quot;pages&#x2F;logs&#x2F;logs&quot;,\n      &quot;text&quot;: &quot;日志&quot;\n    }]\n  }\n}\n\n</code></pre><p>增加了tabBar, 查看调试\n<img src=\"//dn-cnode.qbox.me/Fl-OboTDeCULcPbs5BiM81nj_Xrc\" alt>\n看界面是如此的简陋，为此针对tabBar参考官方说明进行了简单的美化。</p>\n<pre class=\"prettyprint\"><code> &quot;tabBar&quot;:{\n    &quot;color&quot;:&quot;#272636&quot;,\n    &quot;selectedColor&quot;:&quot;#80bd01&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;borderStyle&quot;:&quot;white&quot;,\n    &quot;list&quot;:[{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;首页&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot;\n    },{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;我的&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot;\n    }]\n  }\n</code></pre><p>效果如图\n<img src=\"//dn-cnode.qbox.me/FjzwAq6RH5TstCXIYb5ZIt6z3cuj\" alt>\n最后根据文档，对默认页面的窗口表现进行了修改</p>\n<pre class=\"prettyprint\"><code>  &quot;window&quot;:{\n    &quot;backgroundTextStyle&quot;:&quot;black&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;navigationBarBackgroundColor&quot;:&quot;#000&quot;,\n    &quot;navigationBarTitleText&quot;:&quot;CNODE 应用号版&quot;,\n    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,\n    &quot;enablePullDownRefresh&quot;:&quot;true&quot;\n  },\n</code></pre><p>效果如图\n<img src=\"//dn-cnode.qbox.me/Fl4S7o2m50JXXt1xebSgq1pNR_iX\" alt>\n整体配置文件为</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;pages&quot;:[\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;\n  ],\n  &quot;window&quot;:{\n    &quot;backgroundTextStyle&quot;:&quot;black&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;navigationBarBackgroundColor&quot;:&quot;#000&quot;,\n    &quot;navigationBarTitleText&quot;:&quot;CNODE 应用号版&quot;,\n    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,\n    &quot;enablePullDownRefresh&quot;:&quot;true&quot;\n  },\n  &quot;tabBar&quot;:{\n    &quot;color&quot;:&quot;#272636&quot;,\n    &quot;selectedColor&quot;:&quot;#80bd01&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;borderStyle&quot;:&quot;white&quot;,\n    &quot;list&quot;:[{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;首页&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot;\n    },{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;我的&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot;\n    }]\n  }\n}\n</code></pre><h2>3.制作首页列表</h2>\n<p>根据官方要求，我在pages文件夹内创建了topics文件夹，并创建了对应了 topics.js、topics.wxml、topics.wxss 三个文件。</p>\n<h3>1.注册页面</h3>\n<p>首先在配置文件里注册这个topics,</p>\n<pre class=\"prettyprint\"><code>  &quot;pages&quot;:[\n    &quot;pages&#x2F;topics&#x2F;topics&quot;,\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;\n  ],\n</code></pre><p>并且制定tabBar点击跳到对应的topics页面</p>\n<pre class=\"prettyprint\"><code>  &quot;tabBar&quot;:{\n    &quot;color&quot;:&quot;#272636&quot;,\n    &quot;selectedColor&quot;:&quot;#80bd01&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;borderStyle&quot;:&quot;white&quot;,\n    &quot;list&quot;:[{\n      &quot;pagePath&quot;:&quot;pages&#x2F;topics&#x2F;topics&quot;,\n      &quot;text&quot;:&quot;首页&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot;\n    },{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;我的&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot;\n    }]\n  }\n</code></pre><h5>注意：我发现注册页面的顺序会影响到默认显示tabBar的顺序，所以我把<code>&quot;pages/topics/topics&quot;</code>放到了<code>&quot;pages/index/index&quot;</code>的前面</h5>\n<p>然后编写topics.js</p>\n<pre class=\"prettyprint\"><code>Page({\n  data: {\n    title: &#x27;首页列表&#x27;\n  },\n  onLoad: function () {\n    console.log(&#x27;onLoad by topics&#x27;);\n  }\n});\n</code></pre><p>以及topics.wxml文件</p>\n<pre class=\"prettyprint\"><code>&lt;view class=&quot;topics-main&quot;&gt;\n  测试首页列表界面\n&lt;&#x2F;view&gt;\n</code></pre><p>和topics.wxss文件</p>\n<pre class=\"prettyprint\"><code>.topics-main {\n  background: #f60;\n  height: 100%;\n}\n</code></pre><p>最后效果如图\n<img src=\"//dn-cnode.qbox.me/FiunQ0XhES_sidHnkBN9YxABF2iI\" alt></p>\n<h3>2.创建请求</h3>\n<p>根据文档<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1474887499445\">请求数据</a>，在util文件夹内创建一个api.js文件，专门进行数据请求处理。</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\nvar HOST_URI = &#x27;https:&#x2F;&#x2F;cnodejs.org&#x2F;api&#x2F;v1&#x27;;\n\nvar GET_TOPICS = &#x27;&#x2F;topics&#x27;;\nvar GET_TOPIC_BY_ID = &#x27;&#x2F;topic&#x2F;&#x27;;\n\nfunction obj2uri (obj) {\n    return Object.keys(obj).map(function (k) {\n        return encodeURIComponent(k) + &#x27;=&#x27; + encodeURIComponent(obj[k]);\n    }).join(&#x27;&amp;&#x27;);\n}\n\nmodule.exports = {\n    &#x2F;&#x2F; 获取列表数据\n    getTopics: function (obj) {\n        return HOST_URI + GET_TOPICS + &#x27;?&#x27; + obj2uri(obj);\n    },\n    &#x2F;&#x2F; 获取内容页数据\n    getTopicByID: function (id, obj) {\n        return HOST_URI + GET_TOPIC_BY_ID + id + &#x27;?&#x27; + obj2uri(obj);\n    }\n};\n</code></pre><p>修改topics.js</p>\n<pre class=\"prettyprint\"><code>var Api = require(&#x27;..&#x2F;..&#x2F;utils&#x2F;api.js&#x27;);\n\nPage({\n  data: {\n    title: &#x27;首页列表&#x27;\n  },\n  onLoad: function () {\n    console.log(&#x27;onLoad by topics&#x27;);\n    this.fetchData();&#x2F;&#x2F; 获取数据\n  },\n  fetchData: function (data) {\n    &#x2F;&#x2F; 处理参数\n    if (!data) data = {};\n    if (!data.page) data.page = 1;\n    wx.request({\n      url: Api.getTopics(data),\n      success: function (res) {\n        console.log(res);\n      }\n    });\n  }\n});\n</code></pre><p>效果如图\n<img src=\"//dn-cnode.qbox.me/FoonyAMQBgqDpiTKZshoB3ZmnUEU\" alt>\n成功拿到了数据。</p>\n<h3>3.完善首页列表</h3>\n<p>拿到了数据，也能修改界面，那么就直接完善这个首页吧</p>\n<p>代码就不放了，直接上图\n<img src=\"//dn-cnode.qbox.me/Fo4zG2Vfe50352POPZYXv8Ls0Jcc\" alt>\n我认为这里值得说的大概只有loading、循环、传参、下一页和页面跳转了。</p>\n<h4>1.loading</h4>\n<pre class=\"prettyprint\"><code>  &lt;loading hidden=&quot;{{hidden}}&quot;&gt;\n    加载中...\n  &lt;&#x2F;loading&gt;\n</code></pre><p>在topics.wxml中写官方提供的loading组件，根据在topics.js中对hidden值的修改，来触发loading。</p>\n<h4>2.循环数据，展示列表</h4>\n<p>文档提供了<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1474887501556\">列表渲染</a></p>\n<p>通过<code>wx:for</code>实现列表的渲染。</p>\n<h5>注意: 默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。</h5>\n<pre class=\"prettyprint\"><code>&lt;block wx:for=&quot;{{postsList}}&quot;&gt;\n  &lt;view class=&quot;posts-item&quot; index=&quot;{{index}}&quot; id=&quot;{{item.id}}&quot; catchtap=&quot;redictDetail&quot;&gt;\n    &lt;view class=&quot;author&quot;&gt;\n      &lt;image class=&quot;author-avatar&quot; src=&quot;{{item.author.avatar_url}}&quot;&gt;&lt;&#x2F;image&gt;\n      &lt;view class=&quot;author-name&quot;&gt;{{item.author.loginname}}&lt;&#x2F;view&gt;\n      &lt;view class=&quot;posts-tag hot&quot; wx:if=&quot;{{item.top === true}}&quot;&gt;置顶&lt;&#x2F;view&gt;\n      &lt;view class=&quot;posts-tag&quot; wx:if=&quot;{{item.good === true}}&quot;&gt;精华&lt;&#x2F;view&gt;\n      &lt;view class=&quot;posts-last-reply&quot;&gt;{{item.last_reply_at}}&lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n    &lt;view class=&quot;posts-title&quot;&gt;{{item.title}}&lt;&#x2F;view&gt;\n    &lt;view class=&quot;bar-info&quot;&gt;\n      &lt;view class=&quot;bar-info-item&quot;&gt;\n        &lt;image class=&quot;bar-info-item-icon&quot; src=&quot;&#x2F;images&#x2F;icon&#x2F;reply.png&quot;&gt;&lt;&#x2F;image&gt;\n        &lt;view class=&quot;bar-info-item-number&quot;&gt;{{item.reply_count}}&lt;&#x2F;view&gt;\n      &lt;&#x2F;view&gt;\n      &lt;view class=&quot;bar-info-item&quot;&gt;\n        &lt;image class=&quot;bar-info-item-icon&quot; src=&quot;&#x2F;images&#x2F;icon&#x2F;visit.png&quot;&gt;&lt;&#x2F;image&gt;\n        &lt;view class=&quot;bar-info-item-number&quot;&gt;{{item.visit_count}}&lt;&#x2F;view&gt;\n      &lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;block&gt;\n</code></pre><p>附上一个没有样式的列表展现\n<img src=\"//dn-cnode.qbox.me/FkoTZY1Q9kqOWa1-e70FHifzHVo7\" alt></p>\n<h4>3.传参，实现tab切换</h4>\n<p>根据cnode的api可以知道通过tab不同的值，获得到不同标签下的内容列表。</p>\n<p>所以 在页面的最上面 tab 栏中</p>\n<pre class=\"prettyprint\"><code>  &lt;view class=&quot;top-bar&quot;&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;all&quot; catchtap=&quot;onTapTag&quot;&gt;全部&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;good&quot; catchtap=&quot;onTapTag&quot;&gt;精华&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;share&quot; catchtap=&quot;onTapTag&quot;&gt;分享&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;ask&quot; catchtap=&quot;onTapTag&quot;&gt;问答&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;job&quot; catchtap=&quot;onTapTag&quot;&gt;招聘&lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n</code></pre><p>将id进行定义，通过获取id拿到对应的tab类型。</p>\n<p>其中<code>catchtap</code>是事件绑定。</p>\n<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>\n<p>在topics.js获取</p>\n<pre class=\"prettyprint\"><code>  onTapTag: function (e) {\n    var self = this;\n    var tab = e.currentTarget.id;\n    &#x2F;&#x2F; 这里就能获取到不同的tab值了\n    self.setData({\n      tab: tab\n    });\n    if (tab !== &#x27;all&#x27;) {\n      this.fetchData({tab: tab});\n    } else {\n      this.fetchData();\n    }\n  },\n</code></pre><h4>4.下一页的实现</h4>\n<p>根据文档，组件的视图容器中有<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html?t=1474887496374\">scroll-view</a>这个可滚动视图区域。</p>\n<h5>注意：使用竖向滚动时，需要给&lt;scroll-view/&gt;一个固定高度。</h5>\n<pre class=\"prettyprint\"><code>&lt;scroll-view class=&quot;posts-list&quot; style=&quot;height:100%&quot; scroll-y=&quot;true&quot; bindscrolltolower=&quot;lower&quot;&gt;\n  &lt;block wx:for=&quot;{{postsList}}&quot;&gt;\n    ...\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;scroll-view&gt;\n</code></pre><p>topics.js文件</p>\n<pre class=\"prettyprint\"><code>  lower: function (e) {\n    var self = this;\n    &#x2F;&#x2F; 修改当前页码\n    self.setData({\n      page: self.data.page + 1\n    });\n    &#x2F;&#x2F; 判断当前页的tab值 进行请求数据\n    if (self.data.tab !== &#x27;all&#x27;) {\n      this.fetchData({tab: self.data.tab, page: self.data.page});\n    } else {\n      this.fetchData({page: self.data.page});\n    }\n  }\n</code></pre><h4>5.跳页的实现</h4>\n<p>在<code>posts-item</code>中已经进行了事件绑定。利用<code>wx.navigateTo</code>实现页面的跳转。</p>\n<h5>注意：一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。</h5>\n<pre class=\"prettyprint\"><code>redictDetail: function (e) {\n  console.log(&#x27;我要看详情&#x27;);\n  var id = e.currentTarget.id,\n      url = &#x27;..&#x2F;detail&#x2F;detail?id=&#x27; + id;\n      &#x2F;&#x2F; 这里的detail是需要创建对应的文件，以及页面注册的\n  wx.navigateTo({\n    url: url\n  })\n},\n</code></pre><h3>4.实现详情页</h3>\n<p>同样的原理，创建detail文件，并注册，获取数据，并美化页面。\n<img src=\"//dn-cnode.qbox.me/FmJ5n5-t3gLCfFQTpbzIBS1_ag2L\" alt></p>\n<h3>5.总结</h3>\n<ul>\n<li>微信小应用页面的脚本逻辑在是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能再脚本中使用window，也无法在脚本中操作组件</li>\n<li>同样不能用jquery</li>\n<li>也不能操作dom</li>\n<li>部分标签不支持，比如 h1-h6 会编译报错。</li>\n<li>暂时没找到解决富文本详情页显示的办法。</li>\n<li>整体下来，感觉开发简单，限制很多。</li>\n<li>写过react的看这个确实比较简单。</li>\n</ul>\n<p>放上我的github地址\n<a href=\"https://github.com/coolfishstudio/wechat-webapp-cnode\">https://github.com/coolfishstudio/wechat-webapp-cnode</a></p>\n<p>最后感谢：cnode社区和博卡君</p>\n<p>附上 博卡君的教程</p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/750055\">全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/750495\">博卡君的应用号（小程序）开发教程首发第二弹！（0923）</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/750974\">第三弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/751826\">第四弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/752421\">第五弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/753597\">第六弹！全球首个微信小程序（应用号）开发教程！通宵吐血赶稿！</a>\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n总结一下我遇到的问题\n1.页面没有注册 那么 template 模版无法传递数据 拿不到动态数据 但是能使用wxss\n2.进度条注意右侧百分号 100%的时候 进度条缩短\n3.轮播图加上属性vertical=“vertical/horizontal” 可以修改布局方向，文档没说\n4.有关icon，文档提供默认的只有9个，实际目前测出有15个 success, info, warn, waiting, safe_success, safe_warn,success_circle, success_no_circle, waiting_circle, circle, download,info_circle, cancel, search, clear\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n鉴于有很多童鞋还不了解小应用和h5页面有什么区别\n我决定安利一下我公司的一个文章\n<a href=\"http://url.cn/41kcsQr\">小云百科:什么是“微信小程序”</a></p>\n</div>",
		"title": "分享我用cnode社区api做微信小应用的入门过程",
		"last_reply_at": "2017-03-29T14:32:53.981Z",
		"good": false,
		"top": true,
		"reply_count": 182,
		"visit_count": 45232,
		"create_at": "2016-09-27T07:53:31.872Z",
		"author": {
			"loginname": "coolfishstudio",
			"avatar_url": "https://avatars2.githubusercontent.com/u/8791709?v=3&s=120"
		}
	}, {
		"id": "588a959b1dc8ff8739cbc66d",
		"author_id": "54009f5ccd66f2eb37190485",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h1>Node.js 2016 回顾</h1>\n<h2>1）Node.js版本变化</h2>\n<p><a href=\"https://github.com/nodejs/LTS#lts-schedule\">https://github.com/nodejs/LTS#lts-schedule</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<ul>\n<li>发布Node.js 6.x 并进入LTS（长期支持版本），凡是LTS的都可以在生成环境使用</li>\n<li>发布Node.js 7.x 支持Async/await，尽管需要加flag才可以开启</li>\n</ul>\n<p>根据<a href=\"http://node.green/\">node.green</a>统计Node.js 6.x（LTS下面）的es 2015即es6兼容99%</p>\n<p><a href=\"https://nodesource.com/blog/the-10-key-features-in-node-js-v6-lts-boron-after-you-upgrade\">Node.js 6.x支持的10大关键特性</a></p>\n<ul>\n<li>\n<ol>\n<li>DevTools Inspector Integration</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Capture Names of Listeners on an EventEmitter</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Overhauled Buffers Constructor APIs</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Unhandled Promise rejection warnings</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Quick and Safe Temporary Directory Creation</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Timing Attack Prevention</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Process Warnings API</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Symlink Preservation</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>V8 Performance Profiling Directly Through Node.js</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Process CPU usage</li>\n</ol>\n</li>\n</ul>\n<h2>2）Node.js在2016年被哪些企业使用？</h2>\n<ul>\n<li>高朋使用Node.js重建了整个Web层</li>\n</ul>\n<p>作为决策的结果，高朋团队使用Node.js重建整个Web层</p>\n<p>他们在多个平台使用Node:</p>\n<ol>\n<li>大概3-400个后端服务使用Nde.js Java和Ruby混合</li>\n<li>使用Node作为API集成层。</li>\n<li>使用Node作为后端服务的客户端，包括网站。</li>\n</ol>\n<p>当前，高朋有70个Node.js生产应用。应用在30个国家。</p>\n<ul>\n<li>Node.js在Skycatch应用</li>\n</ul>\n<p>skycatch是家数据公司，帮助捕获、管理和分析商业无人机数据。skycatch看到挖掘数据需要大量查询数据库。使用现有的工具如原始SQL查询是困难和耗时的，而skycatch的解决方案可以方便地从网站中提取可操作的数据。</p>\n<p>“我们在你能想得到的地方都使用了node - Node是我们的胶水”。</p>\n<ul>\n<li>Node.js在Lowe’s Home Improvement 应用</li>\n</ul>\n<p>通过Node.js，工程师队可以拥有从UI到后端整个堆栈的全部开发职责，前端他们能够重用自己在JavaScript和HTML上的精通。</p>\n<p>现在他们可以很快地把新的功能放一起做原型设计做研究和做一些用户测试。然后把这个想法应用到生产级别并发布，不会导致应用程序栈其他部分的风险</p>\n<p>原文http://www.jdon.com/48441</p>\n<p>上面是国外的一些，据我所知很多大公司都用Node.js只是没人出来讲而已，创业公司就更加数不胜数了。</p>\n<p><a href=\"https://cnodejs.org/topic/57612b1ace2caded068f9d80\">调查一下，用Koa的公司来顶一下</a> 这个帖子，7个月之前，统计Koa都很20家左右，所以整体来看，普及力度还不错的。</p>\n<h2>3）left-pad事件</h2>\n<p>2016年3月份，kik是Azer写的模块，但Kik同时是手机通信录的社交软件，所以这个社交软件上就无耻的直接说让Azer把kik名字给他们，Azer不同意，他们就拿律师函恐吓，并让npm妥协，所以npm就妥协了</p>\n<p>Azer一怒之下将自己在 npm 上的 273 个封包全部撤下，其中就包括 left-pad 封包。一石激起千层浪，依赖 left-pad 的上千个项目包括 babel 和 react-native 瞬间崩溃。大量开发者看着自己项目构建失败，顿时被吓尿。</p>\n<p>观点</p>\n<ul>\n<li>\n<p>1）就没见过这么傻逼的公司，一个红包就能解决的事儿，非要用强权，如果对方在改模块上耗费心血少的话，转给你也没啥问题的。去年百度从我手里要走了一个模块，一个红包而已</p>\n</li>\n<li>\n<p>2）11行代码要不要封装成一个包？</p>\n</li>\n</ul>\n<blockquote>\n<p>sindresorhus: Containing complexity is not about putting everything in one-line functions/modules.</p>\n</blockquote>\n<p>你的模块必须含有一定的复杂性，不然就没啥意义了。</p>\n<ul>\n<li>3）npm看着那么多包，大多数都是无意义的吧？</li>\n</ul>\n<p>从我开始讲<a href=\"https://github.com/i5ting/nodejs-fullstack\">Node.js全栈</a>大约是3月份，那是npm上是25.6万个吧，截止到年底是35万个，我想说的是那个包仓库都是有好有坏，按照80/20原则，数量是也是相当可观的。总比那些某些语言连包管理机制都不完善的要强吧！</p>\n<ul>\n<li>4）结果npm调整了撤销策略，24小时之后就不让撤销了</li>\n</ul>\n<blockquote>\n<p>If the version is less than 24 hours old, you can unpublish it. The package will be completely removed from the registry.</p>\n</blockquote>\n<p><a href=\"http://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy\">http://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy</a></p>\n<h2>4）Yarn：一个高效的npm替代品</h2>\n<p>2016年10月份, Facebook 和 Google 联手搞出 Yarn，你一个新的包管理器。一周之内，在github上star过万，现在已经21843个star了。</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h2>5）Chrome DevTools支持Node.js 应用调试了！</h2>\n<p><a href=\"https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools\">https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools</a></p>\n<p>要求</p>\n<ul>\n<li>\n<ol>\n<li>Node.js 6.3+</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>Chrome 55+</li>\n</ol>\n</li>\n</ul>\n<p>步骤</p>\n<ul>\n<li>开启chrome://flags/#enable-devtools-experiments URL</li>\n<li>启动 Developer Tools experiments flag</li>\n<li>重启 Chrome</li>\n<li>打开 DevTools Setting -&gt; Experiments tab (重启之后的才能看见)</li>\n<li>按下 “SHIFT” 6 次</li>\n<li>选中 “Node debugging” 复选框</li>\n<li>打开/关闭 DevTools</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FovQrhrxMpM2sBjtEwN17ugxPHLN\" alt=\"devtool.png\"></p>\n<p><a href=\"https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools\">https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools</a></p>\n<p>另外推荐一个electron包装的devtool，也非常好</p>\n<p><a href=\"https://github.com/Jam3/devtool\">https://github.com/Jam3/devtool</a></p>\n<p><img src=\"https://camo.githubusercontent.com/50a1b83c05a2995479bb27d913e12b6f25557f2c/687474703a2f2f692e696d6775722e636f6d2f56345251535a322e676966\" alt=\"Dev Tools\"></p>\n<h2>6）lerna：一个用户管理多个包模块的工具。</h2>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>非常好用，babel等都大量应用</p>\n<h2>7）Flow和Typescript越来越流行</h2>\n<p>Flow 是一个新的开源JavaScript静态类型检查器给JavaScript增加了静态类型来提高开发人员的生产力和代码质量。特别是，静态类型提供了一些极大的助益，如前期错误检测，它可以帮助您避免某些种运行时故障；如代码的智能提示，这有助于代码维护、导航、转换和优化。</p>\n<p>TypeScript是JavaScript类型（es6）的超集，它可以编译成纯JavaScript。可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。类型检查啊也是非常棒的。</p>\n<p>由于大规模和深度js应用，导致js编写复杂性越来越高，而且又要多人合作，所以对于静态类型的需求会尤其大，flow相对更加轻量级，ts更加像一揽子解决方案。以我的观察，flow就是react这阵风带起来的，喜欢轻量级的可以考虑，长久来看，ts可能会有更大的发展潜力。我相信在2017年ts会有更好的成长，无论是前端，还是Node.js，都会大量应用。</p>\n<h2>8）异步流程演进</h2>\n<p>这里加异步流程演进部分，目的是为了后面讲述框架变化做铺垫，同时异步流程控制也是Node.js非常核心的内容，是每个开发者都必须掌握的。</p>\n<p>JavaScript流程控制的演进过程，分以下6部分:</p>\n<ol>\n<li>同步代码</li>\n<li>异步JavaScript: callback hell</li>\n<li>Thunk</li>\n<li>Promise/a+</li>\n<li>生成器Generators/yield</li>\n<li>Async函数/Await（以前说是ES7 stage-3）</li>\n</ol>\n<p>看起来挺简单的，作为*js（沾边）工程师的各位自测一下，当前是哪个阶段？</p>\n<p>我对异步流程控制的总结</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js已经支持，Node.js 7.x版本需要加flag才能开启，在明年的8.x里会默认开启。</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<h2>9） vsc是一个比较潮比较新的编辑器</h2>\n<p><img src=\"http://code.visualstudio.com/home/home-screenshot-mac-2x.png\" alt></p>\n<p>（跨平台Mac OS X、Windows和 Linux ）</p>\n<ul>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>vsc的宣传语是：</p>\n<pre class=\"prettyprint\"><code> 一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。\n</code></pre><p>按它说的，vsc特别适合来作为前端开发编辑器。</p>\n<p>内置html开发神器emmet(zencoding),对css及其相关编译型语言Less和Sass都有很好的支持。</p>\n<p>当然，最nice的还是写js代码了，这也是我接下来要着重介绍的功能。</p>\n<p>目前vsc已经开源了：</p>\n<ul>\n<li>代码https://github.com/Microsoft/vscode</li>\n<li>官方博客http://blogs.msdn.com/b/vscode/?Redirected=true</li>\n<li>roadmap <a href=\"https://github.com/Microsoft/vscode/wiki/Roadmap\">https://github.com/Microsoft/vscode/wiki/Roadmap</a></li>\n<li>支持go语言 <a href=\"https://github.com/Microsoft/vscode-go\">https://github.com/Microsoft/vscode-go</a></li>\n</ul>\n<p><a href=\"https://github.com/i5ting/vsc\">https://github.com/i5ting/vsc</a></p>\n</div>",
		"title": "Node.js 2016 回顾以及2017展望",
		"last_reply_at": "2017-03-26T10:21:43.238Z",
		"good": false,
		"top": true,
		"reply_count": 56,
		"visit_count": 19971,
		"create_at": "2017-01-27T00:34:35.167Z",
		"author": {
			"loginname": "i5ting",
			"avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
		}
	}, {
		"id": "58df5680b3e60b982d089e0b",
		"author_id": "5888de2b250bf4e2390e9f63",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>中文网址：<a href=\"http://www.vr-react.com/\">http://www.vr-react.com/</a></p>\n<p>好像好神奇的样子。。。</p>\n</div>",
		"title": "刚在社区无意中发现react-vr 这东东，有大神了解这个是干啥的嘛，求科普",
		"last_reply_at": "2017-04-01T07:28:00.427Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 1,
		"create_at": "2017-04-01T07:28:00.427Z",
		"author": {
			"loginname": "yefeng2016",
			"avatar_url": "https://avatars0.githubusercontent.com/u/22342518?v=3&s=120"
		}
	}, {
		"id": "521034bd0a746c580b06bfe1",
		"author_id": "51d7f8e6d44cbfa304bb5f50",
		"content": "<div class=\"markdown-text\"><p>node.JS过于过于深奥很难学，而且学会了只能做网站之类的开发。node.JS 需要不停得依赖v8引擎，v8引擎的更新时不受控制的，爆出漏洞将彻底崩溃。大家需谨慎学习，不要一味贪功</p>\n</div>",
		"title": "大家先放弃学习node.js之理由",
		"last_reply_at": "2017-04-01T07:15:47.106Z",
		"good": false,
		"top": false,
		"reply_count": 101,
		"visit_count": 37779,
		"create_at": "2013-08-18T02:43:09.540Z",
		"author": {
			"loginname": "gentlecolder",
			"avatar_url": "//gravatar.com/avatar/b33dfb4a2308474b4a9d19dcb42c0a10?size=48"
		}
	}, {
		"id": "54882147fa1171ca10c11c78",
		"author_id": "54881f69fa1171ca10c11c73",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>还好有nodejs，否则前端开发工程师手里那不被人看得起的html、css、js能力就被荒废在一遍又一遍的界面改版的痛苦中。\n有了modejs，加上对express框架、nosql数据库的学习，我就可以连同后端业务到前端功能展现统统做完，那个感觉就一个字“爽”，两个字“真爽”，三个字“实在是爽”，对不起字数算错了。\n有了nodejs， APP也不在话下，无论是webapp，还是hybridapp都可以。\n一个产品，我和设计师两个人就搞定了。</p>\n<p>说到这里，还是先学一下nodejs吧，看看再说，否则牛皮吹破了就no zuo no die啦。</p>\n</div>",
		"title": "关于nodejs实现前后端通吃开发模式感想",
		"last_reply_at": "2017-04-01T07:10:24.995Z",
		"good": false,
		"top": false,
		"reply_count": 42,
		"visit_count": 4515,
		"create_at": "2014-12-10T10:32:39.572Z",
		"author": {
			"loginname": "lankeen",
			"avatar_url": "https://avatars.githubusercontent.com/u/8053610?v=3&s=120"
		}
	}, {
		"id": "58df522d6f8b9bf02d1d0d29",
		"author_id": "57aaad434653749872ec6f6b",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>app.js中定义\n<img src=\"//dn-cnode.qbox.me/FhGGHnrqXD-Hty32NsYdXnyLBo4i\" alt=\"untitled3.png\">\n<img src=\"//dn-cnode.qbox.me/FuxkqfL79WWtbi6O7MHKSMQfebXb\" alt=\"untitled4.png\">\n功能模块中使用\n<img src=\"//dn-cnode.qbox.me/FjtpwfWQsqbg76F7CESWyCd77ZwD\" alt=\"untitled5.png\"></p>\n<p>请问这样有问题么，我这里一直是取不到session\n终端里面的req输出\n<img src=\"//dn-cnode.qbox.me/Ft7RZ6fE8QeG-ALcmFws6VGM09Od\" alt=\"untitled6.png\"></p>\n</div>",
		"title": "express-session 取不到session中的值",
		"last_reply_at": "2017-04-01T07:09:33.940Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 16,
		"create_at": "2017-04-01T07:09:33.940Z",
		"author": {
			"loginname": "xumjs8623",
			"avatar_url": "https://avatars3.githubusercontent.com/u/12467615?v=3&s=120"
		}
	}, {
		"id": "58db20cfe9ab80d02d377177",
		"author_id": "586efd62e05ad9c306275087",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>nodeJs中的mysql,如果写一个返回到前台的统一的模板信息?</p>\n<p><img src=\"//dn-cnode.qbox.me/Fk4v5hSZivRaQDTJIk0xLbOLErnj\" alt=\"untitled1.png\"></p>\n<p>如图,假如前台调用这个接口成功了…无论是修改,删除,还是有错误,都应该返回一个json给他…这个json我如何弄成一个模板? 再需要的地方调用就好了…不会每个接口都写一个json单独写吧?\n{\n\tcode:200,\n\treslut:[{…}],\n\tmessages:“成功!”\n}</p>\n<p>如果每个都这样写一遍,岂不是很麻烦了?没模版吗?</p>\n<p>node-mysql默认返回的消息好丑陋,不能定制吗?node-mysql默认返回的消息如下(成功状态下!):\n{\naffectedRows:1\nchangedRows:1\nfieldCount:0\ninsertId:0\nmessage:&quot;(Rows matched: 1  Changed: 1  Warnings: 0&quot;\nprotocol41:true\nserverStatus:2\nwarningCount:0\n}</p>\n</div>",
		"title": "nodeJs中的mysql,如果写一个返回到前台的统一的信息模板?",
		"last_reply_at": "2017-04-01T06:59:07.601Z",
		"good": false,
		"top": false,
		"reply_count": 7,
		"visit_count": 304,
		"create_at": "2017-03-29T02:49:51.409Z",
		"author": {
			"loginname": "caihuattkl",
			"avatar_url": "https://avatars1.githubusercontent.com/u/18523369?v=3&s=120"
		}
	}, {
		"id": "58de52f96f8b9bf02d1d0ce7",
		"author_id": "58de5214b3e60b982d089dc3",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>如题, 跪谢</p>\n</div>",
		"title": "Node中级开发, 有没有比较新的讲解内部原理的书, 深入浅出Nodejs太老了",
		"last_reply_at": "2017-04-01T06:31:48.913Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 277,
		"create_at": "2017-03-31T13:00:41.585Z",
		"author": {
			"loginname": "XiaozhongLiu",
			"avatar_url": "https://avatars0.githubusercontent.com/u/17674404?v=3&s=120"
		}
	}, {
		"id": "58de2124e9ab80d02d377246",
		"author_id": "56fdcb26c5f5b4a959e91751",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>走过路过,不要错过,反正我看完是对js理解更深入了！</p>\n<h2>地址:<a href=\"https://www.geekjc.com\">极客教程</a></h2>\n<h2>目录:</h2>\n<ol>\n<li><a href=\"https://www.geekjc.com/post/58ca7d8d32129645947aec84\">详解setTimeout(fn,0)</a></li>\n<li><a href=\"https://www.geekjc.com/post/58cb5e2132129645947aec85\">详解JS中的事件机制(带实例)</a></li>\n<li><a href=\"https://www.geekjc.com/post/58cd5b206fa70c5678a628af\">详解CommonJS和AMD/CMD！</a></li>\n<li><a href=\"https://www.geekjc.com/post/58ce6a33c1b2ad5e6f2243c7\">详解js中对象的深浅拷贝</a></li>\n<li><a href=\"https://www.geekjc.com/post/58d201dc89a859185d82b9ce\">详解变量声明提升和函数声明提升</a></li>\n<li><a href=\"https://www.geekjc.com/post/58d94d0f16a3655650d6fafe\">详解懒加载和预加载(js)</a></li>\n</ol>\n<p>欢迎关注,不定期更新。</p>\n</div>",
		"title": "弄了个js详解系列",
		"last_reply_at": "2017-04-01T06:27:25.010Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 217,
		"create_at": "2017-03-31T09:28:04.428Z",
		"author": {
			"loginname": "cllgeek",
			"avatar_url": "https://avatars3.githubusercontent.com/u/15187909?v=3&s=120"
		}
	}, {
		"id": "58c5eb5279f557ff16f0f26a",
		"author_id": "571872f41796460c51632e87",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>本文首发<a href=\"https://zhuanlan.zhihu.com/p/25709238\">知乎专栏</a>，是我对中文版 <a href=\"http://link.zhihu.com/?target=https%253A//risingstars2016.js.org/zh/\">risingstars2016</a>  的整理，而本人就是中文版的<a href=\"http://link.zhihu.com/?target=https%253A//github.com/michaelrambeau/risingstars2016/pull/14\">译者</a> 。长江后浪推前浪，如果你能花 30 分钟读完我 6 个小时翻译的内容，相信你不会被后浪拍死在沙滩上，对 2017 该学什么有个清晰的认识。近几年 JS 社区创新和演化的速度是有目共睹的，几个月前比较时髦的技术很可能现在已经过时了。2016 已经过去，你有没有担心错过了什么重要的内容？在这篇调查报告中我们会为你解读社区的主流趋势。</p>\n</blockquote>\n<p>我们将从数量上来分析哪些项目 2016 年获得比较多的关注，具体的做法是比较各项目 2016 年在 Github 上新增 star 的数量。</p>\n<p>回顾 2015 年：<a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a> 无疑占据了统治地位，而 <a href=\"http://link.zhihu.com/?target=http%253A//redux.js.org/\">Redux</a> 则在众多牛毛的 <a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/flux/\">Flux</a> 实现中脱颖而出。那么 2016 年哪些项目最受开发者关注呢？</p>\n<h2><strong>1. 最受欢迎项目</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/FvMob5CNWZbsLUrJjcjFUt4qiEqB\" alt=\"Screen Shot 2017-03-12 at 11.50.09.png\"></p>\n<p>仔细观察 2016 年排名前 10 的项目，你就能对 WEB 社区的演化方向有个直观的把握，概括如下：</p>\n<ul>\n<li>3 个 UI 框架：<a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a>, <a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a> and <a href=\"http://link.zhihu.com/?target=https%253A//angular.io/\">Angular 2</a></li>\n<li>1 个新的 Node.js 包管理器：<a href=\"http://link.zhihu.com/?target=https%253A//yarnpkg.com/\">Yarn</a></li>\n<li>创建桌面应用的首选：<a href=\"http://link.zhihu.com/?target=http%253A//electron.atom.io/\">Electron</a></li>\n<li>创建 react 新项目的首选：<a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a></li>\n<li>1 个移动开发框架：<a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/react-native/\">React Native</a></li>\n<li>最受欢迎的 CSS 工具箱：<a href=\"http://link.zhihu.com/?target=http%253A//getbootstrap.com/\">Bootstrap</a></li>\n<li>函数式编程风格的状态管理库：<a href=\"http://link.zhihu.com/?target=http%253A//redux.js.org/\">Redux</a></li>\n<li>强大兼具灵活的绘图库：<a href=\"http://link.zhihu.com/?target=https%253A//d3js.org/\">D3</a></li>\n</ul>\n<p>上面这些项目覆盖的领域，无疑证明了 JS 的通用性，印证了那句话：<em><strong>能被 JS 编写的，迟早都会被 JS 编写</strong></em>。</p>\n<p><strong>2016 年的最佳项目是… 🏆</strong></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 2016 年新增超过 25000 个 star，意味着平均每天新增 72 个 star，超过了所有同类项目的流行速度，比如 React 和 Angular。 采用 Virtual DOM 来增强性能的 <a href=\"http://link.zhihu.com/?target=https%253A//medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8%2523.lekly4sa8\">Vue.JS v2</a> 于 2016 年 10 月发布。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 已经被不少大公司用在了生产环境中，比如中国最大的电子商务网站里巴巴，所以你可以将 <a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 作为一个安全的选择。</p>\n<p>围绕着 <a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 的社区生态也日趋成熟，包括路由库（<a href=\"http://link.zhihu.com/?target=http%253A//router.vuejs.org/\">vue-router</a>）和状态管理库（<a href=\"http://link.zhihu.com/?target=https%253A//github.com/vuejs/vuex\">Vuex</a>）。 <a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 兼具了 <a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//angularjs.org/\">Angular 1</a> 两者的优点，其中 <a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a> 的基本思想是组件式开发，而 <a href=\"http://link.zhihu.com/?target=http%253A//angularjs.org/\">Angular 1</a> 是模板增强。</p>\n<h2><strong>2. 前端框架</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/FtvkeswZjUfky65QKwprJlOVhQbs\" alt=\"Screen Shot 2017-03-12 at 12.26.49.png\"></p>\n<p>前端框架的百花齐放也许是出现 <a href=\"http://link.zhihu.com/?target=https%253A//medium.freecodecamp.com/javascript-fatigue-fatigue-66ffb619f6ce%2523.soeh5g56p\">JS 疲劳</a> 的原因所在，新的框架、工具和库层出不穷，把创新的车轮推向前进。</p>\n<p>概括来讲，前端框架可以分为两大类：</p>\n<ul>\n<li>大而全的框架，包括创建现代 WEB 应用的所有功能特性，比如路由、数据获取、状态管理，典型项目有：<a href=\"http://link.zhihu.com/?target=http%253A//angularjs.org/\">Angular 1</a>、<a href=\"http://link.zhihu.com/?target=https%253A//angular.io/\">Angular 2</a>、<a href=\"http://link.zhihu.com/?target=http%253A//www.emberjs.com/\">Ember</a> 和 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/aurelia/framework\">Aurelia</a>。</li>\n<li>小而美、聚焦在 UI 层面的解决方案，典型项目有 <a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a>、<a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a>、<a href=\"http://link.zhihu.com/?target=http%253A//infernojs.org/\">Inferno</a>…</li>\n</ul>\n<p>前文中我们已经探讨了排名第 1 的项目 <a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a>，下面来看看其他竞争者：</p>\n<p><strong>React 及其竞争者</strong></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a> 排名第 2，所有开发者都知道 React 有着庞大的社区和完整的生态系统。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a> 设计思想非常流行，受 React 启发而诞生了大量类 React 项目，这些项目继承 React 优点的同时有非常大的改进，比如各种能提高性能和缩短构建时间的瘦身版本。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//infernojs.org/\">Inferno</a> 在类 React 项目中是最受欢迎的，它自己则标榜是所有竞争者中性能最快的。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//preactjs.com/\">Preact</a> 也是一个非常不错的选择，它也有不错的生态，比如各种脚手架、路由，甚至还有一个 <em>compact</em> 模块让任何能在 React 环境运行的库在 Preact 中运行。</p>\n<p><strong>Angular 1 和 Angular 2</strong></p>\n<p>Angular 项目已经被拆分成两个仓库，因为 Angular 2 几乎是 Angular 1 的全面重写，虽然两者在部分概念上是相同的。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//angular.io/\">Angular 2</a> 全部用 TypeScript 编写，这样它利用 ES6 语法特性提供了现代的、全面的 WEB 框架。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//angularjs.org/\">Angular 1</a> (在 Github 上称作 “AngularJS”) 目前仍然被大量的项目使用，目测会持续流行一段时间。</p>\n<p>此外，不得不提的 <a href=\"http://link.zhihu.com/?target=http%253A//www.emberjs.com/\">Ember</a>, 虽然社区和生态都很大，但是没有排到前 10 名。</p>\n<p>整体来看，相比于那些开箱即用的大而全的框架，开发者更青睐自己组合使用那些小而美的轻量级解决方案，因为这样给了他们更大的自由度。</p>\n<h2><strong>3. Node.js 框架</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/Ft-x9AQZeD38BRwGoRNPCEEOLWX6\" alt=\"Screen Shot 2017-03-12 at 12.27.36.png\"></p>\n<p>2016 年创建和部署 Node.js 应用变得空前的容易，比如下面这些解决方案：</p>\n<p>类似于 <a href=\"http://link.zhihu.com/?target=https%253A//gomix.com/\">Gomix</a> 的项目则把 Node.js 的门槛降到不能再低，只要通过浏览器简单的点击拖拽就都能轻而易举的<strong>编写</strong>和<strong>分享</strong> Node.js 代码。</p>\n<p>那么，如果想创建一个 WEB 应用，我们该选哪个框架呢？</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//expressjs.com/\">Express</a></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//expressjs.com/\">Express</a> 已经成为开发 Node.js WEB 应用的标准框架，大多数工程师都很熟悉他的设计思想（极简的内核，但能让你用各种中间件来扩展他的功能）。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//koajs.com/\">Koa</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//koajs.com/\">Koa</a>，设计思想非常类似 <a href=\"http://link.zhihu.com/?target=https%253A//expressjs.com/\">Express</a>，区别在于它是使用 ES6 中的 generator 编写的，这种写法解决了大家所熟知的<a href=\"http://link.zhihu.com/?target=https%253A//www.sitepoint.com/saved-from-callback-hell/\">回调地狱</a> 问题。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//feathersjs.com/\">Feathers</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//feathersjs.com/\">Feathers</a>，是用来实现面向服务架构的一种灵活的解决方案，非常适合创建 Node.js 微服务。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.nodaljs.com/\">Nodal</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.nodaljs.com/\">Nodal</a>，用来创建基于 PostgreSQL 的无状态的、分布式的服务。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.keystonejs.com/\">Keystone</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.keystonejs.com/\">Keystone</a>，是我所知的快速搭建基于 MongoDB 的管理后台的最佳解决方案，Keystone.js 基于数据模型的定义即可自动生成后台界面，支持常见的增删改查操作和灵活的数据过滤。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//sailsjs.com/\">Sails</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//sailsjs.com/\">Sails</a>，是一个全能的 MVC 框架，主要是受到 Ruby on Rails 启发，他已经存在很长时间，支持各种数据库，不管是 SQL 还是 No-SQL。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//loopback.io/\">Loopback</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//loopback.io/\">Loopback</a>，内置了很多特性的成熟框架，支持基于 token 的认证，支持各种数据库。 Loopback 的“杀手锏”功能是 API 浏览器，该功能能让开发者用非常直观的方式查看所有的 API 接口，如果你需要创建 API 服务的话，它无疑是个很好的选择。</p>\n<h2><strong>4. React 项目模板</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/Fm2ipYqNWSQOMx_dDkVTxzGoQyfz\" alt=\"Screen Shot 2017-03-12 at 12.28.09.png\"></p>\n<p>React 是非常棒的 UI 库，但是基于现代 WEB 应用开发工作流创建 React 应用时仍然需要大量的配置才能把所有的部分拼凑到一起，如何创建一个“真实”的 React 应用呢？各种 React 项目模板（boilerplates）和启动工具箱（starter kits）就是来解决这个问题的，典型的有下面几个：</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a></p>\n<p>Facebook 开源的，轻量级的解决方案，使用 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a> 创建 React 应用非常的简单。<a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a> 的作者 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/gaearon\">Dan Abramov</a> (也是 Redux 的作者，目前供职于 Facebook) 在功能丰富和简单可靠之间取得了很好的平衡，没有酷炫的样式解决方案 (仅需纯粹的 CSS) ，没有服务端渲染，但是 React 应用开发的其他方面都浑然一体，开发者体验也非常棒。</p>\n<p>相比于同类工具，如果你使用了 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a>，它会成为你项目的依赖，所有的黑科技都是不可见的，你只能看到你自己的应用代码，你可以随时更新这个依赖。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//reactboilerplate.com/\">React boilerplate</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//reactboilerplate.com/\">React boilerplate</a> 则包含了 React 应用所需的一切，包括 <a href=\"http://link.zhihu.com/?target=http%253A//redux.js.org/\">Redux</a> 以及基于 Web Worker 实现的离线功能。使用它可以创建“渐进式 Web 应用”（亦称“PWA”），如果想了解更多 PWA 的知识，可以阅读 Nicolás Bevacqua 的 <a href=\"http://link.zhihu.com/?target=https%253A//ponyfoo.com/articles/progressive-app-serviceworker\">这篇文章</a>。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//zeit.co/blog/next\">Next.js</a></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//zeit.co/blog/next\">Next.js</a>, 由来自 <a href=\"http://link.zhihu.com/?target=https%253A//zeit.co/\">Zeit</a> 的 busy folks 创建，支持服务端渲染，可以用来创建 universal 应用（或者“同构应用”），直白点说，这种应用的前后端可以运行相同的代码。</p>\n<h2><strong>5. 移动开发</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/Fh_jiaI1pL62eGgidqAW-SXKRJqJ\" alt=\"Screen Shot 2017-03-12 at 12.28.46.png\"></p>\n<p>JS 的通用性是毋庸置疑的，现如今可以用 WEB 工程师非常熟悉的技术（HTML、JS、CSS）构建 Native 移动应用。下面是几个典型的解决方案：</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/react-native/\">React Native</a></p>\n<p>使用 React Native，可以用类似于 React 思路，用同一份代码构建出支持 iOS 和 Android 平台的、真正的 Native 应用，想了解如何构建跨平台的更多内容？建议阅读<a href=\"http://link.zhihu.com/?target=http%253A//makeitopen.com/\">这篇</a>教程。</p>\n<p>其他基于 Cordova 的方案多使用 Webview 来渲染页面，相比于 Native 应用运行时性能会大打折扣，不过，开发者那种 “Write Once Run Everywhere” 的梦想终于成真了！</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//ionicframework.com/\">Ionic</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//ionicframework.com/\">Ionic</a> 是 “hybird” 应用开发领域的先锋，底层基于 Cordova 来访问移动设备的系统功能，社区和生态系统非常成熟。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.nativescript.org/\">NativeScript</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.nativescript.org/\">NativeScript</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/react-native/\">React Native</a> 的目标是相同的，即基于 WEB 技术构建 Native 应用，其核心分为两部分：NativeScript 内核，NativeScript + Angular 2。</p>\n<p><strong>展望未来…</strong></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//weex-project.io/\">Weex</a> 是 2017 年需要密切留意的项目，他是基于 <a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 的、用来创建跨平台移动应用的框架。</p>\n<h2><strong>6. 编译工具</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/FsQNrdDc-myiLIb2XrPi0zUciXqM\" alt=\"Screen Shot 2017-03-12 at 12.29.23.png\"></p>\n<p>我们这里讨论的是把其他语言或者 JS 变体编译（Compiler）或转换成（Transpiler）标准 JS 代码的工具，这些工具生产出来的代码可以在浏览器或者 Node.js 环境中执行。</p>\n<p>最常见的场景是，这类编译工具能够让开发者使用 ES6 语法编写代码，而不用担心浏览器支持情况。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//www.typescriptlang.org/\">TypeScript</a></p>\n<p>最具潜力的编译工具可能是 <a href=\"http://link.zhihu.com/?target=http%253A//www.typescriptlang.org/\">TypeScript</a> 了，它为 JS 带来了类似于 Java 和 C# 的静态类型，而 <a href=\"http://link.zhihu.com/?target=https%253A//angular.io/\">Angular 2</a> 完全使用 TypeScript 的事实让他看起来更诱人，当然关于在 JS 使用静态类型的讨论有很多，建议阅读下面这两篇文章来做出自己的决定：</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//babeljs.io/\">Babel</a></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//babeljs.io/\">Babel</a> + webpack 已经成了 ES6 代码转换、React 模板编译的标准工具组合，<a href=\"http://link.zhihu.com/?target=https%253A//babeljs.io/\">Babel</a> 最初是用来编译 ES6 的，但得益于他的插件系统，如今俨然已经演化成一个用途广泛，几乎能实现各种代码转换的工具。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//flowtype.org/\">Flow</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//flowtype.org/\">Flow</a> 并不是一个编译工具，它只是一个基于 JS 代码标记的静态类型检查工具，也就是说，使用 Flow 时需要在代码中添加各种注释来注明需要的数据类型，关于 Flow 的使用，可以阅读<a href=\"http://link.zhihu.com/?target=http%253A//javascriptplayground.com/blog/2017/01/npm-flowjs-javascript/\">这篇文章</a>。</p>\n<p>Flow 在很多 Facebook 项目的源代码中都有使用，而 Facebook 已经成为开源社区的重要玩家，开源了 <a href=\"http://link.zhihu.com/?target=https%253A//facebook.github.io/react/\">React</a>、<a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/react-native/\">React Native</a>、<a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/flux/\">Flux</a>、<a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/immutable-js/\">Immutable</a>、<a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/jest/\">Jest</a> 等众多的项目，相信你明白这意味着什么。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//coffeescript.org/\">CoffeeScript</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//coffeescript.org/\">CoffeeScript</a> 的简洁语法大量借鉴了 Python 和 Ruby 的语言特性，过去几年曾经是最受欢迎的编译器，但 2016 年很多开发者从 CoffeeScript 转向了 ES6 + <a href=\"http://link.zhihu.com/?target=https%253A//babeljs.io/\">Babel</a> 组合。</p>\n<h2><strong>7. 构建工具</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/Fi8STNt4jTAWF_I1W1f4zrUImbLs\" alt=\"Screen Shot 2017-03-12 at 12.29.47.png\"></p>\n<p>2016 年“构建过程”似乎成了 WEB 项目的标配，如果一个 WEB 应用没有构建过程则是难以想象的事情，在构建过程中通常你需要做编译模板、静态资源合并压缩之类的事情，以为生产环境做好准备。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//webpack.js.org/\">Webpack</a></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//webpack.js.org/\">Webpack</a> 是构建单页应用（SPA）的主要工具，它和 React 生态结合的非常好，最新发布的 Webpack 2 带来了不少非常有前景的改进，具体可以阅读<a href=\"http://link.zhihu.com/?target=https%253A//blog.madewithenvy.com/getting-started-with-webpack-2-ed2b86c68783%2523.7wyiawc0o\">这里</a>。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//gulpjs.com/\">Gulp</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//gulpjs.com/\">Gulp</a> 是一个通用的任务运行工具，可以在任何和文件系统打交道的自动化流程中使用，可以认为它并不是 <a href=\"http://link.zhihu.com/?target=https%253A//webpack.js.org/\">Webpack</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//browserify.org/\">Browserify</a> 的直接竞争者。</p>\n<p>和 <a href=\"http://link.zhihu.com/?target=http%253A//gruntjs.com/\">Grunt</a> 类似，Gulp 的主要角色是任务管理，你可以让它压缩合并代码，但是它不会帮你处理 JS 模块化问题，而 <a href=\"http://link.zhihu.com/?target=https%253A//webpack.js.org/\">Webpack</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//browserify.org/\">Browserify</a> 是可以的。</p>\n<p>当然了，Gulp 可以和 Webpack 结合起来使用，即使开发者倾向于使用 npm script 也是可以的，实际上很多开发者就是这么做的。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//browserify.org/\">Browserify</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//browserify.org/\">Browserify</a> 因为非常简单，在 Node.js 工程师群体中比较受欢迎。简单来说，它把多个 Node.js 的包作为输入，然后输出单个编译后的文件。<strong>相比而言，<a href=\"http://link.zhihu.com/?target=https%253A//webpack.js.org/\">Webpack</a> 在 WEB 应用打包方面考量更多，更适合现代的 WEB 开发工作流。</strong></p>\n<p><strong>展望未来…</strong></p>\n<p>2017 年需要留意的模块打包工具是 <a href=\"http://link.zhihu.com/?target=http%253A//rollupjs.org/\">rollup</a>，它强调的是性能，基于 ES6 的模块规范，并且支持 Tree Shaking 这种黑科技，构建产生的结果只包含实际业务逻辑用到的代码，而不是简单的文件合并。</p>\n<h2><strong>8. 测试框架</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/Fkyfb4nTNpLczb5H860yfyZPxMew\" alt=\"Screen Shot 2017-03-12 at 12.30.13.png\"></p>\n<p>相比于流行了很久的测试框架 <a href=\"http://link.zhihu.com/?target=http%253A//jasmine.github.io/\">Jasmine</a> 和 <a href=\"http://link.zhihu.com/?target=https%253A//mochajs.org/\">Mocha</a>，2016 年出现了 2 个更新的、并有很多人使用的测试框架：<a href=\"http://link.zhihu.com/?target=https%253A//github.com/avajs/ava\">AVA</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/jest/\">Jest</a>。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//github.com/avajs/ava\">AVA</a></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//github.com/avajs/ava\">AVA</a> 由非常高产的 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/sindresorhus\">Sindre Sorhus</a> 开发和维护，其标榜的重点是性能和 ES6，能够并行的运行测试。AVA 的语法非常类似 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/substack/tape\">Tape</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//www.node-tap.org/\">Node-tap</a>。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/jest/\">Jest</a></p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/jest/\">Jest</a>，又一个 Facebook 开源项目，最近几个月引起了大量的开发者注意，在 React 社区更加流行，并且越来越多的人开始迁移到 Jest，可以阅读这个<a href=\"http://link.zhihu.com/?target=https%253A//medium.com/%2540kentcdodds/migrating-to-jest-881f75366e7e%2523.z9x53j1ea\">故事</a>，2017 年 Jest 极有可能成为最受欢迎的测试框架。</p>\n<p>Jest 内置了非常强大的 Mock 特性，而其他的测试框架通常需要依赖第三方的 Mock 包，比如 <a href=\"http://link.zhihu.com/?target=http%253A//sinonjs.org/\">Sinon.JS</a>。</p>\n<h2><strong>9. IDE</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/FlrFHypBv-5SCnLz3SXkMSepfUgO\" alt=\"Screen Shot 2017-03-12 at 12.30.41.png\"></p>\n<p>说到 IDE（集成开发环境，Integrated Development Environment），令人振奋的是最受欢迎的 2 款 IDE 都是用 WEB 技术开发的开源项目。</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//code.visualstudio.com/\">Visual Studio Code</a></p>\n<p>微软的 <a href=\"http://link.zhihu.com/?target=http%253A//code.visualstudio.com/\">Visual Studio Code</a> 在 WEB 开发者群体中非常受欢迎，因为他提供了非常棒的 <a href=\"http://link.zhihu.com/?target=http%253A//www.typescriptlang.org/\">TypeScript</a> 和 Node.js 集成，部分开发者甚至特别提到 <a href=\"http://link.zhihu.com/?target=http%253A//code.visualstudio.com/\">Visual Studio Code</a> 的智能感知功能极大的提高了开发效率。<strong>现在把微软和开源放在一起，终于不那么违和了</strong>。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//atom.io/\">Atom</a></p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//atom.io/\">Atom</a> 由 Github 开源，使用 <a href=\"http://link.zhihu.com/?target=http%253A//electron.atom.io/\">Electron</a> 构建，在受欢迎程度上并没有落后 <a href=\"http://link.zhihu.com/?target=http%253A//code.visualstudio.com/\">Visual Studio Code</a> 太多，关于 Atom 的一个有趣事实是，他所使用的主要语言是 CoffeeScript。</p>\n<h2><strong>10. 静态网站生成器</strong></h2>\n<p><img src=\"//dn-cnode.qbox.me/Fh-s0WRHzQJ_O_al91Ywif6WVptx\" alt=\"Screen Shot 2017-03-12 at 12.31.08.png\"></p>\n<p>静态网站生成器（SSG）是指能够生成一大坨 HTML、CSS、JS 文件方便你快速部署到简单的 WEB 服务器上而不用安装和配置数据库的工具。就像 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/gatsbyjs/gatsby\">Gatsby</a> 所标榜的：</p>\n<blockquote>\n<p>像 1995 年那样构建网站。</p>\n</blockquote>\n<p>静态网站的特点是速度快、健壮性高、容易维护。</p>\n<p>静态网站如此流行的重要原因是市面上有很多非常好用并且免费的静态网站托管解决方案，比如：</p>\n<p><a href=\"http://link.zhihu.com/?target=http%253A//hexo.io/\">Hexo</a></p>\n<p>2016 年最流行的静态网站生成工具是 <a href=\"http://link.zhihu.com/?target=http%253A//hexo.io/\">Hexo</a>，他有点类似于 Workdpress 这样的 CMS 系统，可以用来方便的创建博客网站，他还有很多其他的特性，比如国际化插件。</p>\n<p><a href=\"http://link.zhihu.com/?target=https%253A//github.com/gatsbyjs/gatsby\">Gatsby</a></p>\n<p>新玩家 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/gatsbyjs/gatsby\">Gatsby</a> 是一个比较有趣的解决方案，相比于竞争者优秀的地方在于：它使用 React 生态系统来生成静态文件，可以组合 React Component、Markdown 和服务端渲染来完成静态网站生成让他更强大。</p>\n<h2><strong>总结和展望</strong></h2>\n<p>虽然 2016 年出现了“JS 疲劳”，也发生了戏剧性的事件(如 <a href=\"http://link.zhihu.com/?target=http%253A//developer.telerik.com/featured/left-pad-indicative-fragile-javascript-ecosystem/\">“leftpad 门”</a>)，但总体来讲 2016 年对 JS 社区来说是非常重要的一年，部分项目在 2016 年崛起，如 <a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a> 和 <a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/react-native/\">React Native</a>，还有些黑马项目 2016 年诞生，如 <a href=\"http://link.zhihu.com/?target=https%253A//yarnpkg.com/\">Yarn</a> 和 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a>。</p>\n<p>我们谈论了 2016 年 Github 上最受瞩目的开源项目，但是真正重要的是开发者的满意度，如果你想就这个话题有更量化的认识，建议去看看 Sacha Greif 的调查 <a href=\"http://link.zhihu.com/?target=http%253A//stateofjs.com/\">State of JavaScript</a>，该调查收集了超过 9000 份问卷。</p>\n<p>接下来该思考 2017 年了，哪些将会持续获得开发者的青睐？哪些会成为新星呢？下面是我精选的 10 个我 2016 年比较欣赏，并且 2017 年会继续保持增长的项目或创意：</p>\n<ul>\n<li><a href=\"http://link.zhihu.com/?target=http%253A//vuejs.org/\">Vue.JS</a>：还在快速增长阶段</li>\n<li><a href=\"http://link.zhihu.com/?target=http%253A//electron.atom.io/\">Electron</a></li>\n<li><a href=\"http://link.zhihu.com/?target=https%253A//github.com/facebookincubator/create-react-app\">Create React App</a></li>\n<li><a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/react-native/\">React Native</a></li>\n<li><a href=\"http://link.zhihu.com/?target=https%253A//github.com/gatsbyjs/gatsby\">Gatsby</a> (你浏览的这个页面就是用它来构建的)</li>\n<li><a href=\"http://link.zhihu.com/?target=https%253A//yarnpkg.com/\">Yarn</a>：快速、可靠并且安全的依赖管理工具，可以直接替代 npm，建议阅读文章 <a href=\"http://link.zhihu.com/?target=https%253A//blog.risingstack.com/yarn-vs-npm-node-js-package-managers/\">yarn vs npm</a></li>\n<li>PWA（Progressive Web Applications）渐进式 WEB 应用</li>\n<li>Node.js 微服务的一站式部署和运行解决方案，比如 <a href=\"http://link.zhihu.com/?target=https%253A//zeit.co/now\">Now</a></li>\n<li><a href=\"http://link.zhihu.com/?target=https%253A//nodejs.org/\">Node.js</a> 的进化：最新版本对 ES6 语法的支持已经非常好了</li>\n<li>最后是 <a href=\"http://link.zhihu.com/?target=http%253A//facebook.github.io/graphql/\">GraphQL</a>：我身边不少朋友说这会是一个大的进步</li>\n</ul>\n<p>感谢你花时间阅读本文，可以尽情把本文分享出去，有疑问可以到 <a href=\"http://link.zhihu.com/?target=https%253A//github.com/michaelrambeau/risingstars2016\">Github</a> 上发起 Issue 或直接联系我们。</p>\n<h2>One More Thing</h2>\n<p>想看更多优质技术文章，请订阅我的知乎专栏：<a href=\"https://zhuanlan.zhihu.com/p/zhuanlan.zhihu.com/feweekly!\">前端周刊</a>，每周会发布 1~2 篇高质量技术文章。</p>\n</div>",
		"title": "2016 年崛起的 JS 项目",
		"last_reply_at": "2017-04-01T06:26:32.783Z",
		"good": true,
		"top": false,
		"reply_count": 19,
		"visit_count": 2307,
		"create_at": "2017-03-13T00:44:02.972Z",
		"author": {
			"loginname": "wangshijun",
			"avatar_url": "https://avatars3.githubusercontent.com/u/719985?v=3&s=120"
		}
	}, {
		"id": "58de645903d476b42d34c94b",
		"author_id": "57df88ff7d8293463a01e70b",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>很多天前old big让我测试在async中throw和return的效率，偶然踩中了坑</p>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n    throw new Error();\n}\n(async function test() {\n    for (let i = 0; i &lt; 100000; i++) {\n        try {\n            await foo();\n        } catch (e) {\n        }\n    }\n})();\nconsole.log(&#x27;done&#x27;);\n</code></pre><p>是什么原因呢？</p>\n<p>下面仅仅四行代码也硬了</p>\n<pre class=\"prettyprint language-js\"><code>for (let i = 0; i &lt; 100000; i++) {\n    Promise.reject().catch(e =&gt; { });\n}\nconsole.log(&#x27;done&#x27;);\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 只需一行代码。node就冷静下来了\nglobal.Promise = require(&#x27;bluebird&#x27;);\nfor (let i = 0; i &lt; 100000; i++) {\n    Promise.reject().catch(e =&gt; { });\n}\nconsole.log(&#x27;done&#x27;);\n</code></pre></div>",
		"title": "【震惊】Node爆惊天大bug，影响数千万Node.js进程！他竟然一行代码就修复了！他到底做了啥？",
		"last_reply_at": "2017-04-01T06:04:16.808Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 416,
		"create_at": "2017-03-31T14:14:49.859Z",
		"author": {
			"loginname": "zengming00",
			"avatar_url": "https://avatars1.githubusercontent.com/u/5255081?v=3&s=120"
		}
	}, {
		"id": "58ddec2903d476b42d34c915",
		"author_id": "58169bc4b37ee8fb33978955",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>面试被问到这个问题，懵了，这有什么区别，，求指导</p>\n</div>",
		"title": "定位：：position和float的区别",
		"last_reply_at": "2017-04-01T06:04:15.592Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 151,
		"create_at": "2017-03-31T05:42:01.062Z",
		"author": {
			"loginname": "zhang14725804",
			"avatar_url": "https://avatars2.githubusercontent.com/u/15354910?v=3&s=120"
		}
	}, {
		"id": "57838dfaee5f048d54f90877",
		"author_id": "54009f5ccd66f2eb37190485",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhkG9b2I3tGFc_lK6IeBLb5CM-Rr\" alt=\"Screen Shot 2016-07-11 at 8.30.38 PM.png\"></p>\n<p>缘起<a href=\"https://cnodejs.org/topic/578315dbee5f048d54f90843\">刚开源的3个koa npm包</a>,作者被喷说稍封装就是一个模块</p>\n<p>知名Node.js程序员 <a href=\"https://github.com/sindresorhus/ama/issues/10\">sindresorhus </a>说过</p>\n<blockquote>\n<p>Sometimes code is complex because it has to be. It might handle more edge cases which are found over time and makes the code more durable.</p>\n</blockquote>\n<p>我个人不做评价。索性就把我知道的koa的路由都列一下，以便大家使用或者学习</p>\n<h2>推荐</h2>\n<ul>\n<li><a href=\"https://github.com/alexmingoia/koa-router\">https://github.com/alexmingoia/koa-router</a></li>\n</ul>\n<p>支持1和2，同时是express风格的，功能足够强大</p>\n<h2>官方</h2>\n<ul>\n<li><a href=\"https://github.com/koajs/joi-router\">https://github.com/koajs/joi-router</a></li>\n<li><a href=\"https://github.com/koajs/route\">https://github.com/koajs/route</a></li>\n<li><a href=\"https://github.com/koajs/resourcer\">https://github.com/koajs/resourcer</a></li>\n<li><a href=\"https://github.com/koajs/trie-router\">https://github.com/koajs/trie-router</a></li>\n</ul>\n<h2>其他</h2>\n<ul>\n<li>基于koa-router自动挂载（支持v1和v2） <a href=\"https://github.com/moajs/mount-koa-routes\">https://github.com/moajs/mount-koa-routes</a></li>\n<li>自动挂载 <a href=\"https://github.com/nswbmw/koa-frouter\">https://github.com/nswbmw/koa-frouter</a></li>\n<li>自动挂载 <a href=\"https://www.npmjs.com/package/koa-autoload-router\">https://www.npmjs.com/package/koa-autoload-router</a> =&gt; <a href=\"https://github.com/einsqing/koa-autoload-router\">https://github.com/einsqing/koa-autoload-router</a></li>\n<li><a href=\"https://www.npmjs.com/package/koa-http-router\">https://www.npmjs.com/package/koa-http-router</a> =&gt; <a href=\"https://github.com/einsqing/koa-http-router\">https://github.com/einsqing/koa-http-router</a></li>\n<li><a href=\"https://github.com/alexmingoia/koa-resource-router\">https://github.com/alexmingoia/koa-resource-router</a></li>\n<li><a href=\"https://github.com/song940/koa-routeify\">https://github.com/song940/koa-routeify</a></li>\n<li><a href=\"https://github.com/ivpusic/koa-routing\">https://github.com/ivpusic/koa-routing</a></li>\n<li><a href=\"https://github.com/yiminghe/falcor-koa-router\">https://github.com/yiminghe/falcor-koa-router</a></li>\n<li><a href=\"https://github.com/xpepermint/koa-controller\">https://github.com/xpepermint/koa-controller</a></li>\n<li><a href=\"https://github.com/therne/cottage\">https://github.com/therne/cottage</a></li>\n<li><a href=\"https://github.com/trekjs/route-mapper\">https://github.com/trekjs/route-mapper</a></li>\n<li><a href=\"https://github.com/shimohq/rails-router\">https://github.com/shimohq/rails-router</a></li>\n</ul>\n<h2>koa 2.x</h2>\n<ul>\n<li><a href=\"https://github.com/menems/koa-66\">https://github.com/menems/koa-66</a></li>\n</ul>\n<h2>欢迎补充啊</h2>\n<p>本帖内回复，我会整理的</p>\n</div>",
		"title": "Koa各种路由收集，欢迎补充",
		"last_reply_at": "2017-04-01T05:32:17.179Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 1086,
		"create_at": "2016-07-11T12:15:54.309Z",
		"author": {
			"loginname": "i5ting",
			"avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
		}
	}, {
		"id": "535601a20d7d0faf140303d8",
		"author_id": "5333889a5432b1822f016b2d",
		"content": "<div class=\"markdown-text\"><h1>通过 nodeclub 项目源码来讲解如何做一个 nodejs + express + mongodb 项目</h1>\n<hr>\n<h2>##1. About</h2>\n<ul>\n<li>1.1 <strong>what</strong>:\nnodeclub 是 <a href=\"http://cnodejs.org\">cnodejs.org</a> 的源码，CNode 算是一个基本的博客系统，包含文章发布， 关注，评论等功能。这些功能可以说是任何一个网站的基础。从 nodeclub 里可以学到什么？\n<ul>\n<li>1.基本的架构</li>\n<li>2.开发测试过程</li>\n<li>3.MVC 的设计</li>\n<li>4.middleware 的正确用法</li>\n<li>5.如何设计 Mongodb schema</li>\n<li>6.如何正确的使用 Mongoose</li>\n<li>7.如何实现一个标签系统</li>\n<li>8.plugins? services ?</li>\n<li>9.如何正确的使用 EJS helper</li>\n<li>10.到底该怎样写路由， restful？</li>\n<li>11.如何做基本的控制验证</li>\n<li>12.如何发邮件</li>\n<li>13.session</li>\n<li>14.GitHub 用户登录</li>\n<li>15.图片上传</li>\n<li>16.消息发送</li>\n</ul>\n</li>\n</ul>\n<p>除了 nodeclub 源码的学习笔记以外， 还会有一点最近捣鼓这一块的经验分享</p>\n<ul>\n<li>1.一个完整的消息订阅设计</li>\n<li>2.消息推送, socket + express 如何合作?</li>\n<li>3.包装 action</li>\n<li>4.蛋疼的异步回调如何处理</li>\n</ul>\n<p><a href=\"https://github.com/cnodejs/nodeclub\">nodeclub源码</a></p>\n<ul>\n<li>1.2 <strong>why</strong>:</li>\n</ul>\n<p>对于想用 nodejs  + express + mongodb 来做网站技术基础的项目， nodeclub 可以说是很好的源码级指南，当然也是我的指南，这篇文章权当做个人学习 nodeclub 的学习笔记。</p>\n<ul>\n<li>1.3 <strong>who</strong></li>\n</ul>\n<pre class=\"prettyprint language-coffee\"><code>who = 一名本应该在写前端的但不知怎的一直在写后端的马脓 -&gt; \n  [@echo](&#x2F;user&#x2F;echo) &#x27;github: https:&#x2F;&#x2F;github.com&#x2F;6174&#x27;\n  [@echo](&#x2F;user&#x2F;echo) &#x27;weibo: http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2254313183&#x27;\n  [@echo](&#x2F;user&#x2F;echo) &#x27;email: 57017125[@qq](&#x2F;user&#x2F;qq).com&#x27;\n  [@echo](&#x2F;user&#x2F;echo) &#x27;ps: 一直在求后端partner中，有意者联系我&#x27; \n  [@send](&#x2F;user&#x2F;send)()\n</code></pre><h2>2. nodeclub 中用到了哪些开源技术</h2>\n<hr>\n<ul>\n<li>\n<p>2.1 Node.js 项目一大优点就是有一个 <code>package.json</code>,  里边的 <code>dependencies</code> &amp; <code>devDependencies</code> 可以看到这个项目所有的依赖。 对于有经验的开发者来说， 看完 <code>package.json</code> 基本就能知道项目的架构是怎样。</p>\n</li>\n<li>\n<p>2.2 <strong>dependencies</strong></p>\n</li>\n</ul>\n<ul>\n<li><code>express</code>: 基础框架：</li>\n<li><code>mongodb</code>: 数据存储</li>\n<li><code>mongoose</code>: orm</li>\n<li><code>connect-mongo</code>: session （对于redis， 可以使用connect-redis）</li>\n<li><code>nodemailer</code>：邮件</li>\n<li><code>validator</code>：验证</li>\n<li><code>passport</code>，<code>passport-github</code>： passport，</li>\n<li><code>loader</code>: ejs-view-helper, 静态资源加载处理</li>\n<li>其他： <code>event-proxy</code>, <code>node-markdown</code>, <code>ndir</code></li>\n</ul>\n<ul>\n<li>2.3 <strong>devDependencies</strong></li>\n</ul>\n<ul>\n<li>测试框架：<code>mocha</code>, <code>should</code></li>\n<li>运行： <code>forever</code></li>\n<li>请求模拟: <code>supertest</code></li>\n</ul>\n<ul>\n<li>2.4 nodeclub 以 express + mongodb + mongoose 作为基本框架, 典型的 MVC 应用</li>\n</ul>\n<ul>\n<li><strong>Model</strong>: 对应mongoose orm， models目录</li>\n<li><strong>view</strong>： ejs模板， views目录</li>\n<li><strong>controler</strong>：express middleware , contollers目录</li>\n</ul>\n<ul>\n<li>2.5 目录结构：</li>\n</ul>\n<pre class=\"prettyprint\"><code>- common&#x2F;\n- controllers&#x2F;\n- libs&#x2F;\n# express中间件， 基本的auth， session 验证\n- middlewares&#x2F;\n- models&#x2F;\n#消息， 邮件服务\n- services&#x2F;\n- plugins&#x2F;\n#可以看做是对model处理的加工库\n- proxy&#x2F;\n- test&#x2F;\n- views&#x2F;\n- app.js\n- route.js\n- config.js\n</code></pre><h2>3. 应用入口 <code>app.js</code></h2>\n<hr>\n<p>神圣的入口文件，几乎每个项目都会有一个 entry，对于了解一个应用熟悉入口逻辑很重要。 下面将分步来看看，nodeclub 的 <code>app.js</code> 做了什么：</p>\n<h3>3.1 <code>require(./config)</code></h3>\n<ul>\n<li>3.1.1 应用相关的配置的设置， 主要分为</li>\n</ul>\n<ul>\n<li>1.应用全局数据配置</li>\n<li>2.数据库连接配置</li>\n<li>3.session，auth 相关配置</li>\n<li>4.rss配置</li>\n<li>5.mail配置</li>\n<li>6.第三方连接相关配置， github， weibo</li>\n</ul>\n<p>配置文件也是了解应用的一个好地方， 在 <code>config.default.js</code> 中可以看到以下信息, 这些很可能是我们平时做应用开发的时候没有留意到的地方</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;--应用数据统计\ngoogle_tracker_id: &#x27;UA-41753901-5&#x27;,\n\n&#x2F;&#x2F;--静态文件很可能使用cdn来做\nsite_static_host: &#x27;&#x27;, &#x2F;&#x2F; 静态文件存储域名\n\n&#x2F;&#x2F;--求解释\nsite_enable_search_preview: false, &#x2F;&#x2F; 开启google search preview\nsite_google_search_domain:  &#x27;cnodejs.org&#x27;,  &#x2F;&#x2F; google search preview中要搜索的域名\n\n&#x2F;&#x2F;--运营数据\nlist_topic_count: 20,\npost_interval: 10000,\nadmins: { admin: true },\nside_ads:[]\nallow_sign_up: true,\n\n&#x2F;&#x2F;--插件模式\nplugins: []\n</code></pre><ul>\n<li>3.1.2 当然这里的配置文件是 default 的，配置文件可以放在一个 <code>config</code> 的文件夹下面，多个文件的方式来整理。比如运营数据配置和其他数据配置分开，因为很有可能需要做一个小的工具来让非技术人员配置相关参数。这时候可以用一个 <code>index.js</code> 作为 facade，相当于一个大的 node module。</li>\n</ul>\n<h3>3.2 <code>require('./models')</code></h3>\n<ul>\n<li>3.2.1 之前已经讲了 <code>models/</code> 目录对应 MVC 的 M 部分。</li>\n<li>3.2.2 <code>models/</code> 目录下面有 <code>index.js</code>, <code>require('./models')</code> 相当于 <code>require('./models/index')</code></li>\n</ul>\n<p>index 相当于一个模型的 facade, <code>index.js</code> 做得事情分别是</p>\n<ul>\n<li>1.connect mongodb</li>\n<li>2.require 各个 model 模块</li>\n<li>3.exports 所有的 model</li>\n</ul>\n<p>简单而言就是初始化了应用 model 层。</p>\n<ul>\n<li>3.2.3 模型使用 orm 框架 mogoose 来写，了解 mogoose 过后， models 部分的代码也就是秒懂了</li>\n</ul>\n<p>， 我说的只是代码，literaly, 一个项目的核心就是 model 的设计，以前做过的任何项目都是一样， 数据库 table 的设计好坏直接影响应用的开发以及性能。 下面来看看各个 model 的 schema 设计(几乎直接 ctr+c, ctr+v 加上了一点点注释) :</p>\n<ul>\n<li>3.2.4 user</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var UserSchema = new Schema({\n  &#x2F;&#x2F;--基本用户信息， index表示在mongodb中会建立索引\n  &#x2F;&#x2F;--unique: true 唯一性设置\n  name: { type: String, index: true },\n  loginname: { type: String, unique: true },\n  pass: { type: String },\n  email: { type: String, unique: true },\n  url: { type: String },\n  profile_image_url: {type: String},\n  location: { type: String },\n  signature: { type: String },\n  profile: { type: String },\n  weibo: { type: String },\n  avatar: { type: String },\n  githubId: { type: String, index: true },\n  githubUsername: {type: String},\n  is_block: {type: Boolean, default: false},\n  \n  &#x2F;&#x2F;--用户产生数据meta\n  score: { type: Number, default: 0 },\n  topic_count: { type: Number, default: 0 },\n  reply_count: { type: Number, default: 0 },\n  follower_count: { type: Number, default: 0 },\n  following_count: { type: Number, default: 0 },\n  collect_tag_count: { type: Number, default: 0 },\n  collect_topic_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  is_star: { type: Boolean },\n  level: { type: String },\n  active: { type: Boolean, default: true },\n    \n  &#x2F;&#x2F;-mail\n  receive_reply_mail: {type: Boolean, default: false },\n  receive_at_mail: { type: Boolean, default: false },\n  from_wp: { type: Boolean },\n  retrieve_time : {type: Number},\n  retrieve_key : {type: String}\n});\n</code></pre><ul>\n<li>3.2.5 topic 话题</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;1 &lt;- 多\n&#x2F;&#x2F;tag &lt;- topic &lt;- collect  \nvar TopicSchema = new Schema({\n  title: { type: String },\n  content: { type: String },\n  author_id: { type: ObjectId },\n  top: { type: Boolean, default: false },\n  reply_count: { type: Number, default: 0 },\n  visit_count: { type: Number, default: 0 },\n  collect_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  &#x2F;&#x2F;--这里reply的设计方式不知道是否合适， 因为mongdb不同于关系型数据库，这里每次读取文章都需要重reply集合里边查找遍历一边，文章是读繁忙的。\n  &#x2F;&#x2F;-- 一个document的大小为5Mb， 一本牛津词典的内容， 我觉得将reply放在这里应该不会有太大问题。 即便不存放reply 内容， 存放一个id数组也会好很多。\n  &#x2F;&#x2F;-- 客官们怎么看?  \n  last_reply: { type: ObjectId },\n  last_reply_at: { type: Date, default: Date.now },\n  content_is_html: { type: Boolean }\n});\n\nvar ReplySchema = new Schema({\n  content: { type: String },\n  topic_id: { type: ObjectId, index: true },\n  author_id: { type: ObjectId },\n  reply_id : { type: ObjectId },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  content_is_html: { type: Boolean }\n});\n\n&#x2F;&#x2F;--话题集合\nvar TopicCollectSchema = new Schema({\n  user_id: { type: ObjectId },\n  topic_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n\n&#x2F;&#x2F;--话题标签\nvar TopicTagSchema = new Schema({\n  topic_id: { type: ObjectId },\n  tag_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});     \n</code></pre><ul>\n<li>3.2.6 tag\n标签系统</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;tag &lt;- collect\nvar TagSchema = new Schema({\n  name: { type: String },\n  order: { type: Number, default: 1 },\n  description: { type: String },\n  background: { type: String },\n  topic_count: { type: Number, default: 0 },\n  collect_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now }\n});\n\nvar TagCollectSchema = new Schema({\n  user_id: { type: ObjectId, index: true },\n  tag_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n</code></pre><ul>\n<li>3.2.7 关系</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var RelationSchema = new Schema({\n  user_id: { type: ObjectId },\n  follow_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n</code></pre><ul>\n<li>3.2.8 消息\n消息 model 设计， 对于一个 blog 来说， 基本的只有回复消息， 这里加了关注和@消息。</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;*\n * type:\n * reply: xx 回复了你的话题\n * reply2: xx 在话题中回复了你\n * follow: xx 关注了你\n * at: xx ＠了你\n *&#x2F;\nvar MessageSchema = new Schema({\n  type: { type: String },\n  master_id: { type: ObjectId, index: true },\n  author_id: { type: ObjectId },\n  topic_id: { type: ObjectId },\n  reply_id: { type: ObjectId },\n  has_read: { type: Boolean, default: false },\n  create_at: { type: Date, default: Date.now }\n});\n</code></pre><p>###3.3 require middlewares</p>\n<ul>\n<li>\n<p>3.3.1 express 的基础是 middleware，或者说 express 的基础是 connect，connect 的基础是 middleware。middleware 模式在 professional nodejs 中有一个专门的章节来讲解。何为 middleware 呢？ middleware 模式 相当于一个加工流水线（大家叫 middleware stack），每一个 middleware 相当于一个加工步骤，当出现一个 http 请求的时候，http 请求会挨着每个 middleware 执行下去。\nexpress 里处理一个请求的过程基本上就是请求通过 middleware stack 的过程：  * -&gt; middlewares -&gt; 路由 -&gt; controllers -&gt; errorhandlering。</p>\n</li>\n<li>\n<p>3.3.2 middleware 怎样做到的， 异步的方法呢？ middleware 使用 promise 的方式来处理异步，所有每个 middleware 都有三个参数 <code>req, res, next</code>, 对于异步的情况， 必须要调用 <code>next()</code> 方法。不然后续的 middleware 就无法执行。 ps: debug 的时候没调用 <code>next()</code> 还不会报错，一定注意</p>\n</li>\n<li>\n<p>3.3.3 auth.js</p>\n</li>\n</ul>\n<p><code>auth.js</code> exports 出来的函数全部都是中间件，从变量名就完全清楚的知道到底在做什么了</p>\n<pre class=\"prettyprint language-javascript\"><code>\n&#x2F;&#x2F;-- 需要admin权限\nexports.adminRequired = function (req, res, next) {}\n\n&#x2F;&#x2F;-- 需要有用户\nexports.userRequired = function (req, res, next) {}\n\n&#x2F;&#x2F;-- 需要有用户并登录\nexports.signinRequired = function (req, res, next) {\n    if (!req.session.user) {\n        res.render(&#x27;notify&#x2F;notify&#x27;, {error: &#x27;未登入用户不能发布话题。&#x27;});\n        return;\n    }\n    next();   \n}\n\n&#x2F;&#x2F;-- 屏蔽用户 -_-\nexports.blockUser = function (req, res, next) {}\n</code></pre><p>这里其实就可以看到中间件的作用了，我们以前写 php 的时候每次都需要判断用户是否登录， 没登陆 redirect 到 <code>index.php</code> ，只不过这里的方式是通过中间件来处理。\n明白这里什么意思，其他的中间件模块也就秒懂了。</p>\n<p>###3.4 require(’./routes’)</p>\n<ul>\n<li>\n<p>3.4.1 express 的世界里另外一个很重要的就是route， Node.js 启动的是服务， 监听了某一端口， 接受 http or https or socket 请求,   那 url 中像 <code>/index.php?blabla</code> 这一串的存在怎么处理呢， express 的 route 功能就可以帮我们解析。</p>\n</li>\n<li>\n<p>3.4.2 MVC 中如何将一个请求和 controller 联系起来呢， route 就是这样的纽带</p>\n</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;--get, post 请求\napp.get(&#x27;&#x2F;signin&#x27;, sign.showLogin);\napp.post(&#x27;&#x2F;signin&#x27;, sign.login);\n&#x2F;&#x2F;--使用中间件\napp.get(&#x27;&#x2F;signup&#x27;, configMiddleware.github, passport.authenticate(&#x27;github&#x27;));\napp.post(&#x27;&#x2F;:topic_id&#x2F;reply&#x27;, auth.userRequired, limit.postInterval, reply.add);\n</code></pre><ul>\n<li>3.4.3 route 是了解一个应用最佳的地方，一个请求如何处理， 到相应的 controller 去看就知道了。 相比起在PHP环境下配置更加灵活。当然你说你通过nginx来配置也很灵活，好吧，我们说的不是一回事。</li>\n</ul>\n<h3>3.5 initialization</h3>\n<ul>\n<li>3.5.1 experess initialize: <code>app.js</code> 中其他大多部分就是express的初始化了， 初始化流程如下：</li>\n</ul>\n<ul>\n<li>1.配置上传 upload_dir</li>\n<li>2.模板引擎设置</li>\n<li>3.express 通用中间件设置</li>\n<li>4.pasport 中间件</li>\n<li>5.自定义中间件\n<ul>\n<li>1.auth_user</li>\n<li>2.block_user</li>\n<li>3.staticfile: upload</li>\n<li>4.staticfile: user_data</li>\n</ul>\n</li>\n<li>6.csrf</li>\n<li>7.errorhandler</li>\n<li>8.set view cache</li>\n</ul>\n<p><code>[@Note](/user/Note)</code>：配置的顺序很重要， 中间件的执行顺序是按照定义顺序来执行的， 如果一个中间件依赖另外的中间件， 而自己先执行了， 这种情况就会错误。 常见的问题就是session配置， 一定要记得配置 session 中间件的时候， 要先配置 cookieParser。</p>\n<ul>\n<li>3.5.2 session 设置</li>\n</ul>\n<p>这个步骤在 initialize 里边已经有了， 不过再单独讲一下， nodeclub 使用的是 connect-mongo 来作为 session 的存储</p>\n<pre class=\"prettyprint language-javascript\"><code>  &#x2F;&#x2F;--cookieParser一定要在前面， 因为session的设置依赖cookie\n  app.use(express.cookieParser());\n  app.use(express.session({\n    secret: config.session_secret,\n    store: new MongoStore({\n      db: config.db_name,\n    }),\n  }));\n</code></pre><ul>\n<li>3.5.3 view helpers</li>\n</ul>\n<p>使用过 ejs 的肯定知道， ejs 里边 view helper 设置很简单， 就像赋值变量一样。 当对于一些通用的 helper 可以这样设置：</p>\n<pre class=\"prettyprint language-javascript\"><code>    app.helpers({\n      config: config,\n      Loader: Loader,\n      assets: assets\n    });\n    app.dynamicHelpers(require(&#x27;.&#x2F;common&#x2F;render_helpers&#x27;));\n</code></pre><ul>\n<li>3.5.4 github pasport initialize</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; github oauth\n    passport.serializeUser(function (user, done) {\n      done(null, user);\n    });\n    passport.deserializeUser(function (user, done) {\n      done(null, user);\n    });\n    passport.use(new GitHubStrategy(config.GITHUB_OAUTH, githubStrategyMiddleware));\n</code></pre><ul>\n<li>3.5.5 start app</li>\n</ul>\n<h2>##4. 用户注册</h2>\n<ul>\n<li>4.1 user 是每个应用都会处理的基本， 注册登录登出， 看看 nodeclub 做了哪些事情：</li>\n<li>4.2 路由：</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;--设置能否直接注册， 不能的话通过github注册\nif (config.allow_sign_up) {\n  app.get(&#x27;&#x2F;signup&#x27;, sign.showSignup);\n  app.post(&#x27;&#x2F;signup&#x27;, sign.signup);\n} else {\n  app.get(&#x27;&#x2F;signup&#x27;, configMiddleware.github, passport.authenticate(&#x27;github&#x27;));\n}\napp.post(&#x27;&#x2F;signout&#x27;, sign.signout);\napp.get(&#x27;&#x2F;signin&#x27;, sign.showLogin);\napp.post(&#x27;&#x2F;signin&#x27;, sign.login);\n</code></pre><ul>\n<li>4.3 controller &amp; model：sign.signup</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>sanitize = validator.sanitize;\ncheck = validator.check;\nexports.signup = function (req, res, next) {\n  &#x2F;&#x2F;--xss 消毒\n  var name = sanitize(req.body.name).trim();\n  name = sanitize(name).xss();\n  ...\n  &#x2F;&#x2F;--validations\n  try {\n    check(name, &#x27;用户名只能使用0-9，a-z，A-Z。&#x27;).isAlphanumeric();\n  } catch (e) {\n    res.render(&#x27;sign&#x2F;signup&#x27;, {error: e.message, name: name, email: email});\n    return;\n  }\n  ...\n  &#x2F;&#x2F;--用用户名登录或者email登录\n  query = {&#x27;$or&#x27;: [{&#x27;loginname&#x27;: loginname}, {&#x27;email&#x27;: email}]}\n  User.getUserByQuery(query, {}, function(){\n    ...\n    pass = md5(pass);\n    ...\n    User.newAndSave(name, loginname, pass, email, avatar_url, false, function (err) {\n      ...\n      &#x2F;&#x2F; 发送激活邮件\n      mail.sendActiveMail(email, md5(email + config.session_secret), name);\n      res.render(&#x27;sign&#x2F;signup&#x27;, {\n        success: &#x27;欢迎加入 &#x27; + config.name + &#x27;！我们已给您的注册邮箱发送了一封邮件，请点击里面的链接来激活您的帐号。&#x27;\n      });\n    })\n  })\n}   \n</code></pre><h2>##5. mongoose 的使用</h2>\n<ul>\n<li>5.1 使用User.newAndSave，</li>\n<li>5.2 异步 callback pyramid</li>\n</ul>\n<p>一个应用通常会遇到这样的情景， 一个页面需要的数据包括， 文章列表， 评论列表，用户数据，广告数据， other stuff…   问题是每个都是异步的， 怎么办。 user 数据获取过后的 callback 调用文章列表获取， 文章列表获取的 callback 调用评论列表的获取… 这样就太蛋疼了。  nodeclub 使用了 eventproxy 模块优雅的解决这样的问题：</p>\n<pre class=\"prettyprint language-javascript\"><code>  render = function(){}\n  var proxy = EventProxy.create(&#x27;tags&#x27;, &#x27;topics&#x27;, &#x27;hot_topics&#x27;, &#x27;stars&#x27;, &#x27;tops&#x27;, &#x27;no_reply_topics&#x27;, &#x27;pages&#x27;, render);\n  proxy.fail(next);\n  Tag.getAllTags(proxy.done(&#x27;tags&#x27;));\n  Topic.getTopicsByQuery(query, options, proxy.done(&#x27;topics&#x27;));\n  User.getUsersByQuery({ is_star: true }, { limit: 5 }, proxy.done(&#x27;stars&#x27;));\n</code></pre><p>看完代码不言而喻。。。\n当然异步处理的方法有很多:</p>\n<ul>\n<li>1.基于事件的：eventProxy</li>\n<li>2.基于promise的：Async.js Q.js, when.js</li>\n<li>3.基于编译的：continuation, wind</li>\n<li>4.基于语言语法的：yield， livescript</li>\n</ul>\n<p>文章最后会讲一下我我的异步选择方案</p>\n<h2>##6. 消息</h2>\n<ul>\n<li>6.1 原先以为有动态的消息推送， 有队列处理， 错了， 木有</li>\n<li>6.2 在 Sublime text 里边全局搜索 <code>sendReply2Message</code> 会发现是在 <code>controller/reply.js</code> 里边调用的， 也就是说，消息是直接触发的。</li>\n<li>6.3 好吧， 这部分大概大家都能秒懂。。</li>\n</ul>\n<h2>##7. 开发</h2>\n<p>###7.1 测试</p>\n<ul>\n<li>7.1.1 一个项目必定离不开测试， nodeclub基于mocha BDD测试框架， 一切的前提假设至少能看懂jasmine或者mocha或者任何一个BDD风格的测试代码。</li>\n<li>7.1.2  打开即看到app.js</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var app = require(&#x27;..&#x2F;app&#x27;);\ndescribe(&#x27;app.js&#x27;, function () {\n  &#x2F;&#x2F;--before， 执行it的前面会执行\n  before(function (done) {\n    &#x2F;&#x2F;--done, 异步方法\n    app.listen(3001, done);\n  });\n  after(function () {\n    app.close();\n  });\n  it(&#x27;should &#x2F; status 200&#x27;, function (done) {\n    &#x2F;&#x2F;--使用 app.request()就可以模拟请求了？ 这个api哪里来的， 求解释？\n    app.request().get(&#x27;&#x2F;&#x27;).end(function (res) {\n      res.should.status(200);\n      done();\n    });\n  });\n});\n&#x2F;&#x2F;--按理说应该是可以正常运行了但是我一直出现这个错误:\n&#x2F;&#x2F;--connect ADDRNOTAVAIL 知道的求解释\n&#x2F;&#x2F;--我尝试用supertest直接测试， 但是也是一直timeout， mocha\n&#x2F;&#x2F;--里边加大timeout时间， 结果就是一直没反应。 \n\n&#x2F;&#x2F;--分析原因， express版本问题， nodeclub中express的版本还是2.x, 所以才会有\n&#x2F;&#x2F;--app.request(), app.close()这些api\n&#x2F;&#x2F;--第二个原因， 到supertest官网， 发现人家都已经转战到superagent项目了， 于是我写了下面这个测试脚本， 可以通过了\nvar express = require(&#x27;express&#x27;);\nvar should = require(&#x27;should&#x27;);\nvar path = require(&#x27;path&#x27;);\nvar superagent = require(&#x27;superagent&#x27;);\nvar app = express()\napp.get(&#x27;&#x2F;user&#x27;, function(req, res, next) {\n    res.send(200, {\n        name: &#x27;tobi&#x27;\n    })\n})\ndescribe(&#x27;myapp.js&#x27;, function() {\n    this.timeout(5000)\n    before(function(done) {\n        app.listen(21, done);\n    })\n    after(function() {\n        &#x2F;&#x2F; app.close()\n    })\n    it(&#x27;should &#x2F;status 200&#x27;, function(done) {\n        agent = superagent.agent()\n        agent.get(&#x27;http:&#x2F;&#x2F;localhost:21&#x2F;user&#x27;).end(function(err, res) {\n          console.log(err, res)\n          res.should.have.status(200);\n          res.text.should.include(&#x27;tobi&#x27;);\n          return done();\n        });\n    })\n})\n</code></pre><p>###7.2 运行</p>\n<ul>\n<li>nodejs是单线程应用， 如果我们用node命令来运行我们的应用， 当出现一个小错误， 它就挂了。 然后没有然后了。  避免这种问题的方法有如下工具：</li>\n</ul>\n<ul>\n<li>1.forever</li>\n<li>2.nodemon</li>\n<li>3.supervisor\nnodeclub 使用 forever 来运行项目， 使用这类工具的好处就是， 当有代码改动过后， 会自动的重启应用。 不必每次自己去运行 <code>node *.js</code></li>\n</ul>\n<h2>##8. 说说自己的经验</h2>\n<p>待续…\n###8.1 消息订阅设计\n###8.2 express + socket\n###8.3 异步\n###8.4 Action</p>\n</div>",
		"title": "通过 nodeclub 项目源码来讲解如何做一个 nodejs + express + mongodb 项目",
		"last_reply_at": "2017-04-01T05:11:26.178Z",
		"good": true,
		"top": false,
		"reply_count": 81,
		"visit_count": 34496,
		"create_at": "2014-04-22T05:44:02.557Z",
		"author": {
			"loginname": "6174",
			"avatar_url": "https://avatars.githubusercontent.com/u/3872872?v=3&s=120"
		}
	}, {
		"id": "58ddb7ba03d476b42d34c8fe",
		"author_id": "4efc278625fa69ac690001ad",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>帖子已经写晚了，不过春天来不及，夏天还来得及。</p>\n<pre class=\"prettyprint\"><code>1.  最重要的一条，同一家公司（尤其大公司）简历不能多投、乱投，部门之间简历是有锁的，到了A部门就不能B部门了。 所以别人问你要简历，要慎重，先聊聊岗位的职责，业务方向（能有可见的产品，那更直观一些），再决定投哪边。\n\n2.  PDF格式</code></pre></div>",
		"title": "【校招必看】简历不要乱投哦",
		"last_reply_at": "2017-04-01T04:54:54.499Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 344,
		"create_at": "2017-03-31T01:58:18.642Z",
		"author": {
			"loginname": "fish",
			"avatar_url": "//gravatar.com/avatar/d24fc5b1c6b84dae95dd23ba1c7ebbcb?size=48"
		}
	}, {
		"id": "58de04936f8b9bf02d1d0cc3",
		"author_id": "5263ce409df724eb6d290523",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>总是不让我请求啊，如果是rejectUnauthorized: false又会请求超时<img src=\"//dn-cnode.qbox.me/Fm93ucOWr7a-kM5oMVCK5Zgx7xwp\" alt=\"1.png\"><img src=\"//dn-cnode.qbox.me/FjMIgghJRIoRv5FYfs4rhZA-ekrt\" alt=\"2.png\"></p>\n</div>",
		"title": "https求解",
		"last_reply_at": "2017-04-01T04:54:13.635Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 146,
		"create_at": "2017-03-31T07:26:11.677Z",
		"author": {
			"loginname": "racyily",
			"avatar_url": "//gravatar.com/avatar/547de05c179eb9ddcc36ddf23b6e2046?size=48"
		}
	}, {
		"id": "58dc7af06f8b9bf02d1d0c30",
		"author_id": "58dc785f03d476b42d34c8b8",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fq7C6uuCJyabLHFjv24FrwcbNkWP\" alt=\"pm2 表格 异常.png\"></p>\n</div>",
		"title": "Nodejs  pm2    表格呈现异常   如何解决？",
		"last_reply_at": "2017-04-01T04:39:26.350Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 229,
		"create_at": "2017-03-30T03:26:40.707Z",
		"author": {
			"loginname": "wangruixiang",
			"avatar_url": "https://avatars2.githubusercontent.com/u/25861379?v=3&s=120"
		}
	}, {
		"id": "58df19e9b3e60b982d089deb",
		"author_id": "54475fdf649ac9220757b8ed",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>除了自动驾驶，语音识别等应用层，眼下人工智能的一个研究方向就是技术层自身， AI 也将产生颠覆——让机器自己编程。谷歌 DeepMind 、 Facebook 等团队都致力于这一方向上的研究，如果代码也可以进行自我分析、自我编码并自我修正，由此带来的进步是无止境的：更自然的机器人、更智能的手机、更少的 bug 等。</p>\n</blockquote>\n<p>今天我们怀着激动的心情，正式向大家公布 Coding 团队多年秘密研发的革命性产品 —— Coding AI 。基于 Coding 平台亿万行代码数据特征总结出的代码分析算法， Coding AI 采用机器学习技术，自动评测了海量代码并进行分析学习，现在已具有自动编写代码、自行 Debug 、语音聊天等功能。为进行验证，我们精选了 10 道编程能力测试题，充分测试了 Coding AI 的编程能力。此外我们还邀请了资深开发者对其进行电话面试，平均面试时间为 18 分钟。经过 Coding 测试后，我们对其进行了进一步的封装，最终打包成为 Coding AI 。</p>\n<p><img src=\"https://dn-coding-net-production-pp.qbox.me/cfadea84-7345-4c18-9a33-62b8558acd9f.jpg?imageView2/2/w/500/h/500&amp;imageMogr2/format/jpg/ignore-error/1\" alt>\n<em>Coding AI 正在对海量代码进行分析学习</em></p>\n<h4>如何使用 Coding AI ？</h4>\n<p>如果你有软件开发的需求（如网站设计制作， App 设计制作等），都可以雇佣 Coding AI 。 我们提供三天免费试用时长，期间如您不满意可随时更换 Coding AI 。同时， Coding 码市的「开发宝」作为费用结算工具，您可以自定义付费周期，执行资金自动托管，确认与验收，确保与 Coding AI 的交易过程安全、高效、省心。</p>\n<p><strong>为进一步测试改进 Coding AI 使其拥有与开发者相同的沟通和技术水平， Coding AI 将进行灰度发布，即我们将 Coding 平台开发者混入其中，你将有 60% 的概率分配到 Coding AI ，同时无论你匹配到的是 Coding AI 或开发者，页面一律提示为人类开发者。我们将致力于让 Coding AI 拥有与人类同样的技术能力与聊天技巧，如果你通过比对发现了与你匹配到的是 Coding AI ，请告知我们，这将非常有利于 Coding AI 的研究与开发。</strong></p>\n<p><a href=\"https://mart.coding.net/talents/find\">点此进入 Coding AI 选择页面</a></p>\n<p><img src=\"https://dn-coding-net-production-pp.qbox.me/a62d0ba2-3f2a-4ba8-80f8-f3c41c5b51dd.png?imageView2/2/w/500/h/500&amp;imageMogr2/format/png/ignore-error/1\" alt></p>\n<p>Coding ，让开发更简单！</p>\n</div>",
		"title": "Coding AI 发布，引领全球进入人工智能编程时代",
		"last_reply_at": "2017-04-01T04:17:11.008Z",
		"good": false,
		"top": false,
		"reply_count": 4,
		"visit_count": 168,
		"create_at": "2017-04-01T03:09:29.910Z",
		"author": {
			"loginname": "zengliqi",
			"avatar_url": "https://avatars.githubusercontent.com/u/9347370?v=3&s=120"
		}
	}, {
		"id": "58ddc40b6f8b9bf02d1d0ca1",
		"author_id": "58ddbda46f8b9bf02d1d0c93",
		"tab": "job",
		"content": "<div class=\"markdown-text\"><h3>我们花光八辈子运气，只为遇到你</h3>\n<h3>集团总部 XO Group</h3>\n<p>XO Group (资讯集团The Knot) 是美国最大婚尚资讯集团，同时也是纽交所上市集团，股票代码为“XOXO”。旗下包括了网站、杂志、电视节目、相关书籍等诸多媒体资产，业务涵盖了婚尚资讯（<a href=\"http://theknot.com\">theknot.com</a>）、家居生活（<a href=\"http://thenest.com\">thenest.com</a>）、母婴产品（<a href=\"http://thebump.com\">thebump.com</a>），旗下网站月访问量均超过1亿次，注册用户超过300万，是美国在线交易额最大的婚尚网站！</p>\n<h2>诺特软件 GZ TheKnot</h2>\n<p>广州诺特软件开发有限公司成立于2009年7月，是XO Group Inc全资控股的软件开发中心，为XO Group的网站和客户提供技术支持。现已成长为2011-2012年度广东重点软件出口企业，2013-2015年广州市技术先进型企业。</p>\n<h2>薪酬福利</h2>\n<ul>\n<li>薪资优厚，快速晋升机会，五险一金均齐全（试用期即缴纳）；</li>\n<li>完善的培训体系，技术大牛导师和女神级别英语外教，优秀同事还能出国参加中美交流计划，让你华丽转身，跻身高手行列！</li>\n<li>丰富的生活福利，包括弹性工作制、高大上团队建设活动、轻奢公司旅游，还提供五 彩缤纷的零食柜，满足你的隐藏吃货属性；</li>\n<li>月度年度优秀奖励一个不少，同事融洽，领导贴心，跟优秀的人在一起！</li>\n<li>地处核心CBD，交通便利，更有开放式的舒适办公环境，</li>\n<li>按摩椅、健康体检、健康讲座，全方位呵护你的身心健康！</li>\n</ul>\n<h2>招聘岗位</h2>\n<h3>Node.js开发工程师</h3>\n<h4>【职位要求】</h4>\n<p>负责公司核心业务系统后台开发\n1.大专或以上学历，计算机或者相关专业毕业\n2.1年或以上NodeJS开发经验\n3.非常熟悉NodeJS LTS (4.2.x)的特性，有PostgreSQL开发经验\n4.熟悉Hapi系列modules，以及Chai系列和Sinon系列的单元测试modules\n5.熟悉基于Express框架的开发，熟练使用HTML/CSS/客户端JavaScript\n6.有AngularJS开发经验者优先考虑\n7.有Rabbit Message Queue的开发经验或者Elasitc Search开发经验者优先考虑\n8.能够阅读英文文档，具备一定英文编写能力\n9.良好的编程风格，独立思考有高度的工作责任感\n10.具有团队开发意识；良好的沟通协调能力，较好的语言表达能力，较好的文字处理能力</p>\n<h2>职位待遇</h2>\n<p>6K以上，由你的能力及经验决定，待遇从优，详细面谈。</p>\n<h2>相关链接</h2>\n<p>[集团美国网站] (<a href=\"http://xogroupinc.com/\">http://xogroupinc.com/</a>)\n[集团中国网站] (<a href=\"http://www.tkcnsoft.com/\">http://www.tkcnsoft.com/</a>)\n联 系 人：HR &amp; Admin Department\n地 址：广州市天河路45号天伦大厦903\n电 话 : +8620 3830 3638 - 376\n简历可发往：[aqiu@xogrp.com] (<a href=\"mailto:aqiu@xogrp.com\">aqiu@xogrp.com</a>)</p>\n<h4>精彩缤纷的公司旅游</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2017/c3ca49f77989ce71b2eb9352c16d95f2.jpg!large\" alt></p>\n<h4>完善丰富的内外部培训</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2016/26b3c50f2139230892a6757cd6710219.jpg!large\" alt></p>\n<h4>开放宽松的办公环境</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2016/726e577ef434909803611481eec799d5.png!large\" alt></p>\n<h4>别开生面的公司活动</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2017/c6ca3d53af4fbd7d2049daf4712cd953.jpg!large\" alt></p>\n</div>",
		"title": "【广州诺特招聘】春风十里不如你，秋念一心只为卿—Node.js工程师3名",
		"last_reply_at": "2017-04-01T04:16:20.090Z",
		"good": false,
		"top": false,
		"reply_count": 6,
		"visit_count": 142,
		"create_at": "2017-03-31T02:50:51.811Z",
		"author": {
			"loginname": "xogroupTim",
			"avatar_url": "https://avatars1.githubusercontent.com/u/26758199?v=3&s=120"
		}
	}, {
		"id": "58de63a703d476b42d34c94a",
		"author_id": "58dc5819e9ab80d02d3771c0",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>目前在做前端，水的不要不要的，打算学习一下node，有没有哪位前辈要办培训班的，可以辞了职去学。</p>\n</div>",
		"title": "求node前辈",
		"last_reply_at": "2017-04-01T04:12:15.208Z",
		"good": false,
		"top": false,
		"reply_count": 4,
		"visit_count": 177,
		"create_at": "2017-03-31T14:11:51.711Z",
		"author": {
			"loginname": "bedodo",
			"avatar_url": "https://avatars3.githubusercontent.com/u/22236946?v=3&s=120"
		}
	}, {
		"id": "58ddd7a303d476b42d34c911",
		"author_id": "53d391a0895ba3062b7ee7f5",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h1>协程</h1>\n<h2>什么是协程</h2>\n<p>wikipedia 的定义：\n协程是一个无优先级的子程序调度组件，允许子程序在特点的地方挂起恢复。</p>\n<p>线程包含于进程，协程包含于线程。只要内存足够，一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p>\n<h2>为什么需要协程</h2>\n<h3>简单引入</h3>\n<p>就实际使用理解来讲，协程允许我们写同步代码的逻辑，却做着异步的事，避免了回调嵌套，使得代码逻辑清晰。code like this:</p>\n<pre class=\"prettyprint language-js\"><code>   co(function*(next){\n     let [err,data]=yield fs.readFile(&quot;.&#x2F;test.txt&quot;,next);&#x2F;&#x2F;异步读文件\n     [err]=yield fs.appendFile(&quot;.&#x2F;test2.txt&quot;,data,next);&#x2F;&#x2F;异步写文件\n     &#x2F;&#x2F;....\n   })()\n</code></pre><blockquote>\n<p><strong>异步</strong> 指令执行之后，结果并不立即显现的操作称为异步操作。及其指令执行完成并不代表操作完成。</p>\n</blockquote>\n<p>协程是追求极限性能和优美的代码结构的产物。</p>\n<h3>一点历史</h3>\n<p>起初人们喜欢同步编程，然后发现有一堆线程因为I/O卡在那里,并发上不去，资源严重浪费。</p>\n<p>然后出了异步（select,epoll,kqueue,etc）,将I/O操作交给内核线程,自己注册一个回调函数处理最终结果。</p>\n<p>然而项目大了之后代码结构变得不清晰,下面是个小例子。</p>\n<pre class=\"prettyprint language-js\"><code>  async_func1(&quot;hello world&quot;,func(){\n     async_func2(&quot;what&#x27;s up?&quot;,func(){\n       async_func2(&quot;oh ,friend!&quot;,func(){ \n         &#x2F;&#x2F;todo something\n       })\n     })\n  })\n</code></pre><p>于是发明了协程，写同步的代码，享受着异步带来的性能优势。</p>\n<blockquote>\n<p><strong>程序运行是需要的资源</strong>：</p>\n</blockquote>\n<ul>\n<li>cpu</li>\n<li>内存</li>\n<li>I/O (文件、网络，磁盘（内存访问不在一个层级，忽略不计）)</li>\n</ul>\n<h2>协程的实现原理（c++和node.js里面的实现）</h2>\n<h3>libco 一个C++协程库实现</h3>\n<p>libco 是腾讯开源的一个C++协程库，作为微信后台的基础库，经受住了实际的检验。项目地址：<a href=\"https://github.com/Tencent/libco\">https://github.com/Tencent/libco</a></p>\n<p>个人源码阅读项目：<a href=\"https://github.com/yyrdl/libco-code-study\">https://github.com/yyrdl/libco-code-study</a> （未完结）</p>\n<p>libco源代码文件一共11个，其中一个是汇编代码，其余是C++，阅读起来相对较容易。</p>\n<p>在C++里面实现协程要解决的问题有如下几个：</p>\n<ul>\n<li>何时挂起协程？何时唤醒协程？</li>\n<li>如何挂起、唤醒协程，如何保护协程运行时的上下文？</li>\n<li>如何封装异步操作？</li>\n</ul>\n<h4>前期知识准备</h4>\n<ol>\n<li>现代操作系统是分时操作系统，资源分配的基本单位是进程，CPU调度的基本单位是线程。</li>\n<li>C++程序运行时会有一个运行时栈，一次函数调用就会在栈上生成一个record</li>\n<li>运行时内存空间分为全局变量区（存放函数，全局变量）,栈区，堆区。栈区内存分配从高地址往低地址分配，堆区从低地址往高地址分配。</li>\n<li>下一条指令地址存在于指令寄存器IP，ESP寄存值指向当前栈顶地址，EBP指向当前活动栈帧的基地址。</li>\n<li>发生函数调用时操作为：将参数从右往左依次压栈，将返回地址压栈，将当前EBP寄存器的值压栈，在栈区分配当前函数局部变量所需的空间，表现为修改ESP寄存器的值。</li>\n<li>协程的上下文包含属于他的栈区和寄存器里面存放的值。</li>\n</ol>\n<h3>何时挂起，唤醒协程？</h3>\n<p>如开始介绍时所说，协程是为了使用异步的优势，异步操作是为了避免IO操作阻塞线程。那么协程挂起的时刻应该是当前协程发起异步操作的时候，而唤醒应该在其他协程退出，并且他的异步操作完成时。</p>\n<h3>如何挂起、唤醒协程，如何保护协程运行时的上下文？</h3>\n<p>协程发起异步操作的时刻是该挂起协程的时刻，为了保证唤醒时能正常运行，需要正确保存并恢复其运行时的上下文。</p>\n<p>所以这里的操作步骤为：</p>\n<ul>\n<li>保存当前协程的上下文（运行栈，返回地址，寄存器状态）</li>\n<li>设置将要唤醒的协程的入口指令地址到IP寄存器</li>\n<li>恢复将要唤醒的协程的上下文</li>\n</ul>\n<p>这部分操作相应的源代码：</p>\n<pre class=\"prettyprint language-S\"><code>.globl coctx_swap&#x2F;&#x2F;定义该部分汇编代码对外暴露的函数名\n#if !defined( __APPLE__ )\n.type  coctx_swap, @function\n#endif\ncoctx_swap:\n\n#if defined(__i386__)\n\tleal 4(%esp), %eax &#x2F;&#x2F;sp   R[eax]=R[esp]+4 R[eax]的值应该为coctx_swap的第一个参数在栈中的地址\n\tmovl 4(%esp), %esp  &#x2F;&#x2F;    R[esp]=Mem[R[esp]+4] 将esp指向 &amp;(curr-&gt;ctx) 当前routine 上下文的内存地址，ctx在堆区，现在esp应指向reg[0]\n\tleal 32(%esp), %esp &#x2F;&#x2F;parm a : &amp;regs[7] + sizeof(void*)   push 操作是以esp的值为基准，push一个值,则esp的值减一个单位（因为是按栈区的操作逻辑，从高位往低位分配地址），但ctx是在堆区，所以应将esp指向reg[7]，然后从eax到-4(%eax)push\n    &#x2F;&#x2F;保存寄存器值到栈中，实际对应coctx_t-&gt;regs 数组在栈中的位置（参见coctx.h 中coctx_t的定义）\n\tpushl %eax &#x2F;&#x2F;esp -&gt;parm a\n\n\tpushl %ebp\n\tpushl %esi\n\tpushl %edi\n\tpushl %edx\n\tpushl %ecx\n\tpushl %ebx\n\tpushl -4(%eax) &#x2F;&#x2F;将函数返回地址压栈，即coctx_swap 之后的指令地址，保存返回地址,保存到coctx_t-&gt;regs[0]\n\n    &#x2F;&#x2F;恢复运行目标routine时的环境（各个寄存器的值和栈状态）\n\tmovl 4(%eax), %esp &#x2F;&#x2F;parm b -&gt; &amp;regs[0] &#x2F;&#x2F;切换esp到目标 routine  ctx在栈中的起始地址,这个地址正好对应regs[0],pop一次 esp会加一个单位的值\n\n\tpopl %eax  &#x2F;&#x2F;ret func addr regs[0] 暂存返回地址到 EAX\n\t&#x2F;&#x2F;恢复当时的寄存器状态\n\tpopl %ebx  &#x2F;&#x2F; regs[1]\n\tpopl %ecx  &#x2F;&#x2F; regs[2]\n\tpopl %edx  &#x2F;&#x2F; regs[3]\n\tpopl %edi  &#x2F;&#x2F; regs[4]\n\tpopl %esi  &#x2F;&#x2F; regs[5]\n\tpopl %ebp  &#x2F;&#x2F; regs[6]\n\tpopl %esp  &#x2F;&#x2F; regs[7]\n\t&#x2F;&#x2F;将返回地址压栈\n\tpushl %eax &#x2F;&#x2F;set ret func addr\n    &#x2F;&#x2F;将 eax清零\n\txorl %eax, %eax\n\t&#x2F;&#x2F;返回，这里返回之后就切换到目标routine了，C++代码中调用coctx_swap的地方之后的代码将得不到立即执行\n\tret\n\n#elif\n</code></pre><p>这部分代码只是做了寄存器部分的操作。依赖的结构体定义，见文件coctx.h中：</p>\n<pre class=\"prettyprint language-c++\"><code>struct coctx_t\n{\n#if defined(__i386__)\n\tvoid *regs[ 8 ];&#x2F;&#x2F;32位机，依次为：ret,ebx,ecx,edx,edi,esi,ebp,eax\n#else\n\tvoid *regs[ 14 ];&#x2F;&#x2F;64位机的情况\n#endif\n\tsize_t ss_size;&#x2F;&#x2F;空间大小\n\tchar *ss_sp;&#x2F;&#x2F;ESP\n\t\n};\n</code></pre><p>调用coctx_swap 函数只在文件co_routine.cpp中的co_swap函数。</p>\n<p>保存运行栈的操作见co_swap函数中调用coctx_swap之前的部分。具体步骤为取当前栈顶地址 （代码：<code>char c; esp=&amp;c</code>）,若不是共享栈模型则清理下env，若是则判断共享栈区有没有被占用，被占用则从堆区申请内存保存，然后再分配共享栈。</p>\n<p>需要注意的是，libco运行时的栈区不在是传统意义上的栈区，其空间实际来自于堆区。</p>\n<h3>如何封装异步操作？</h3>\n<p>这部分代码见：</p>\n<ul>\n<li>co_hook_sys_call.cpp</li>\n<li>co_routine.cpp</li>\n<li>co_epoll.cpp</li>\n<li>co_epoll.h</li>\n</ul>\n<p>核心思想是hook系统本来的I/O接口，比如<code>socket()</code>函数，和epoll(kqueue)结合，采用一个<code>co_eventloop</code>来统一管理，当发现一个协程发起异步操作时，就将其挂起放入等待队列，唤醒其他异步操作已经完成的协程。可以联系libevent里面的event_loop，区别在在于一个是操作栈区和寄存器恢复协程，一个是调用绑定的回调函数。</p>\n<h2>node.js里面协程</h2>\n<p>node.js 的优势：</p>\n<ul>\n<li>node.js天生异步（下面是libuv）</li>\n<li>javascript的闭包特性完成了上下文的保存工作</li>\n</ul>\n<p>需要我们做的：</p>\n<ul>\n<li>实现同步编程</li>\n</ul>\n<p>附上 文章开始时的代码：</p>\n<pre class=\"prettyprint language-js\"><code>   const fs=require(&quot;fs&quot;);\n   const co=require(&quot;zco&quot;);\n   \n   co(function*(next){\n     let [err,data]=yield fs.readFile(&quot;.&#x2F;test.txt&quot;,next);&#x2F;&#x2F;异步读文件\n     [err]=yield fs.appendFile(&quot;.&#x2F;test2.txt&quot;,data,next);&#x2F;&#x2F;异步写文件\n     &#x2F;&#x2F;....\n   })()\n</code></pre><h3>JS 中的Generator</h3>\n<p>Generator是一个迭代器生成器,也是node.js中实现协程的关键。</p>\n<pre class=\"prettyprint language-js\"><code>\nlet gen=function *() {\n    console.log(&quot;ok1&quot;);\n    var a=yield 1;\n    console.log(&quot;a:&quot;+a);\n    var b=yield 2;\n    console.log(&quot;b:&quot;+b);\n}\n\n\nvar iterator=gen();\nconsole.log(&quot;ok2&quot;);\n\nconsole.log(iterator.next(100));\nconsole.log(iterator.next(101));\nconsole.log(iterator.next(102));\n</code></pre><p>输出：</p>\n<pre class=\"prettyprint\"><code>ok2\nok1\n{ value: 1, done: false }\na:101\n{ value: 2, done: false }\nb:102\n{ value: undefined, done: true }\n</code></pre><p>从这里我们可以看到其执行顺序，以及各个值的变化。iterator.next() 返回的值即yield 之后的表达式的返回值，yield之前的变量的值即iterator.next方法传入的值。通过这个特性，合理包装即可实现coroutine.</p>\n<p>以下是<code>zco</code>模块源码，项目地址：<a href=\"https://github.com/yyrdl/zco%EF%BC%9A\">https://github.com/yyrdl/zco：</a></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * Created by yyrdl on 2017&#x2F;3&#x2F;14.\n *&#x2F;\nvar slice = Array.prototype.slice;\n\nvar co = function (gen) {\n\n\tvar iterator,\n\tcallback = null,\n\thasReturn = false;\n\n\tvar _end = function (e, v) {\n\t\tcallback &amp;&amp; callback(e, v); &#x2F;&#x2F;I shoudn&#x27;t catch the error throwed by user&#x27;s callback\n\t\tif(callback==null&amp;&amp;e){&#x2F;&#x2F;the error should be throwed if no handler instead of  catching silently\n\t\t\tthrow e;\n\t\t}\n\t}\n\tvar run=function(arg){\n\t\ttry {\n\t\t\tvar v = iterator.next(arg);\n\t\t\thasReturn = true;\n\t\t\tv.done &amp;&amp; _end(undefined, v.value);\n\t\t} catch (e) {\n\t\t\t_end(e);\n\t\t}\n\t}\n\tvar nextSlave = function (arg) {\n\t\thasReturn = false;\n\t\trun(arg);\n\t}\n\t\n\tvar next = function () {\n\t\tvar arg = slice.call(arguments);\n\t\tif (!hasReturn) {&#x2F;&#x2F;support fake async operation,avoid error: &quot;Generator is already running&quot;\n\t\t\tsetTimeout(nextSlave, 0, arg);\n\t\t} else {\n\t\t\tnextSlave(arg);\n\t\t}\n\t}\n\t\n\tif (&quot;[object GeneratorFunction]&quot; === Object.prototype.toString.call(gen)) {&#x2F;&#x2F;todo: support other Generator implements \n\t\titerator = gen(next);\n\t} else {\n\t\tthrow new TypeError(&quot;the arg of co must be generator function&quot;)\n\t}\n\n\tvar future = function (cb) {\n\t\tif (&quot;function&quot; == typeof cb) {\n\t\t\tcallback = cb;\n\t\t}\n\t\trun();\n\t}\n\n\treturn future;\n}\n\nmodule.exports = co;\n</code></pre></div>",
		"title": "协程概念，原理（c++和node.js实现）",
		"last_reply_at": "2017-04-01T03:58:33.801Z",
		"good": true,
		"top": false,
		"reply_count": 5,
		"visit_count": 345,
		"create_at": "2017-03-31T04:14:27.743Z",
		"author": {
			"loginname": "yyrdl",
			"avatar_url": "https://avatars2.githubusercontent.com/u/8213509?v=3&s=120"
		}
	}, {
		"id": "58dc66df6f8b9bf02d1d0c1e",
		"author_id": "57067a058265278d59c7e61f",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>亲们，我在做自动化测试／单元测试。有一个小问题请教一下大家。例如我要测试a.js，而我在b.js中写测试用例。我想一次性忽略a.js中的日志语句，但是又不能手动在a.js中添加类似：/<em>istanbul ignore next</em>/的语句。意思就是a中日志语句不计入测试覆盖率。如何解决啊？</p>\n</div>",
		"title": "自动化测试中，如何同时忽略日志语句？",
		"last_reply_at": "2017-04-01T03:57:24.114Z",
		"good": false,
		"top": false,
		"reply_count": 19,
		"visit_count": 349,
		"create_at": "2017-03-30T02:01:03.826Z",
		"author": {
			"loginname": "sunfeng90",
			"avatar_url": "https://avatars2.githubusercontent.com/u/11543206?v=3&s=120"
		}
	}, {
		"id": "58dce216b3e60b982d089d44",
		"author_id": "58dce0346f8b9bf02d1d0c63",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>在使用node做项目或者开发的时候，常常会因为一个功能迷茫，发现找不到想要的资源。例如：我想使用mock.js，来模拟ajax请求，实现前后端分离。但是我去nodejs上面找模块的时候，完全不知道搜索什么？或者我按照mock搜索，出现的东西并不是自己想要的！这种时候应该怎么办？------（我最理想的是mock2easynew模块，这种理想的模块，如果之前没有接触过完全不知道怎么找到，谁有好的办法？）-----其实就是不知道怎么在nodejs上面搜模块，它上面只支持固定名字的搜索，没有模糊搜索，不知道名字，基本上就搜不到想要的模块？请问各位是怎么找到需要的模块的？？？？？？</p>\n</div>",
		"title": "如何寻找好用的node模块？",
		"last_reply_at": "2017-04-01T03:56:13.544Z",
		"good": false,
		"top": false,
		"reply_count": 10,
		"visit_count": 318,
		"create_at": "2017-03-30T10:46:46.490Z",
		"author": {
			"loginname": "nowRookie",
			"avatar_url": "https://avatars1.githubusercontent.com/u/22513072?v=3&s=120"
		}
	}, {
		"id": "58dc6b81b3e60b982d089d0c",
		"author_id": "58d83c586f8b9bf02d1d0b1d",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>var a=require(&quot;./a &quot;)为什么加载不出来?</p>\n<p>因为a后面多了个空格…</p>\n<p>字符串果然是个严谨的东西…</p>\n</div>",
		"title": "require惊天大bug!",
		"last_reply_at": "2017-04-01T03:53:10.242Z",
		"good": false,
		"top": false,
		"reply_count": 19,
		"visit_count": 795,
		"create_at": "2017-03-30T02:20:49.622Z",
		"author": {
			"loginname": "ResJay",
			"avatar_url": "https://avatars3.githubusercontent.com/u/26635410?v=3&s=120"
		}
	}, {
		"id": "58ddf9fde9ab80d02d377233",
		"author_id": "5745079cfd93c1011f94aaf0",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>在日常开发中</p>\n<ol>\n<li>可能编辑器会有bug，调试的时候占用端口</li>\n<li>多个调试程序启动，发现端口占用，找出哪个程序什么端口很麻烦</li>\n</ol>\n<p>分享一个通用的端口占用工具 killport2</p>\n<p><a href=\"https://github.com/kelvv/killport2\">github地址</a></p>\n<p>安装：</p>\n<pre class=\"prettyprint\"><code>npm install killport2 -g\n</code></pre><p>使用：</p>\n<pre class=\"prettyprint\"><code>很简单，如果3000端口占用，如下：\n  killport 3000\n</code></pre><p>完事</p>\n<p>支持系统：  windows 、macos 、 linux</p>\n</div>",
		"title": "轻松解决端口占用问题",
		"last_reply_at": "2017-04-01T03:26:37.918Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 246,
		"create_at": "2017-03-31T06:41:01.632Z",
		"author": {
			"loginname": "kelvv",
			"avatar_url": "https://avatars1.githubusercontent.com/u/19403268?v=3&s=120"
		}
	}, {
		"id": "58dee4abb3e60b982d089dd5",
		"author_id": "571872f41796460c51632e87",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>共 7717 字，读完需 10 分钟，速读需 5 分钟，适合中高级前端工程师，本文对主流的 E2E 测试框架做了简单对比，期望对大家的技术选型有帮助。</p>\n</blockquote>\n<p>测试，尤其是自动化测试在现代 WEB 工程中有着非常重要的角色，与交付过程集成良好的自动化测试流程可以在新版发布时帮你快速回归产品功能，也可以充当产品文档。测试因粒度不同又可以分为单元测试、接口测试、功能测试。在 WEB 领域，功能测试亦称为<code>端到端测试</code>（<a href=\"https://www.tutorialspoint.com/software_testing_dictionary/end_to_end_testing.htm\">End to End Test</a>，简称 <code>E2E 测试</code>），笔者在本文中会结合自身实践和 GitHub 趋势对比最受欢迎的 Node.js E2E 测试解决方案，首先我们按 GitHub 的 star 总数量排序，取前 5 名列举如下（注意：你阅读本文时 star 的数量可能已经不是最新的）。</p>\n<ul>\n<li>CasperJS — 6460 个 star，<a href=\"http://casperjs.org/\">官网</a>，<a href=\"https://github.com/casperjs/casperjs\">代码</a>，最近更新于 7 天前；</li>\n<li>Protractor — 6408 个 star，<a href=\"http://www.protractortest.org/\">官网</a>，<a href=\"https://github.com/angular/protractor\">代码</a>，最近更新于 10 天前；</li>\n<li>Nightwatch.js — 6121 个 star，<a href=\"http://nightwatchjs.org/\">官网</a>，<a href=\"https://github.com/nightwatchjs/nightwatch\">代码</a>，最近更新于 6 天前；</li>\n<li>TestCafe — 2268 个 star，<a href=\"https://devexpress.github.io/testcafe/\">官网</a>，<a href=\"https://github.com/DevExpress/testcafe\">代码</a>，最近更新于 1 天前；</li>\n<li>CodeceptJS — 1087 个 star，<a href=\"http://codecept.io/\">官网</a>，<a href=\"https://github.com/Codeception/CodeceptJS\">代码</a>，最近更新于 7 天前；</li>\n</ul>\n<p>然后分别从环境搭建、测试编写、测试报告等方面来直观展示这 5 个 E2E 测试框架，期望能够对做测试框架选型的同学有帮助。为了更客观的体现各测试框架的特点，笔者设计了一些包含 E2E 测试中常用操作的测试用例，分别使用不同的框架来编写。E2E 测试的常用操作如下：</p>\n<ul>\n<li>打开网页，跳转网页：打开 Github 的首页；</li>\n<li>填写输入框，提交表单：键入搜索词，提交搜索表单；</li>\n<li>元素单击等操作：单击搜索结果的第一项；</li>\n<li>元素数量、属性检视：确认搜索结果展示了 10 条；</li>\n<li>页面运行环境检视：确认页面的地址是正确的；</li>\n</ul>\n<h3>CasperJS</h3>\n<p><a href=\"http://casperjs.org/\">CasperJS</a> 是 star 数最高的测试框架，也是笔者最早开始采用的 E2E 测试框架，使用 Python 编写，虽不算是严格意义上的原生 Node.js 解决方案，但因为能够使用 npm 安装，且能够很好的与 Node.js 工具链组合使用，笔者还是把它列在了这里。其特别之处在于只能与无界面浏览器（Headless Browser）组合使用，比如 <a href=\"http://phantomjs.org/\">PhantomJS</a> 和 <a href=\"https://slimerjs.org/\">SlimerJS</a>，这也让 CasperJS 的优势显而易见：测试运行速度比真实浏览器快不少，且你不需要在持续集成系统中安装各种浏览器或者某个浏览器的不同版本；潜在的坑在于，无界面浏览器的表现有时和真实浏览器不完全相同，会带来某些难以排查解决的浏览器兼容问题。</p>\n<h4>安装步骤</h4>\n<ul>\n<li>安装 Python 2.6 或更高版本</li>\n<li>安装 PhantomJS：<code>npm install -g phantomjs</code></li>\n<li>安装 CasperJS：<code>npm install -g casperjs</code></li>\n</ul>\n<h4>编写测试</h4>\n<p>如果使用 ES6 之前的风格来编写 CasperJS 测试，代码看起来会显得非常臃肿，而实际上 CasperJS 也不支持任何 ES6/ES7 的新语法，除非你在运行测试之前自己对代码进行预编译，实际代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>casper.test.begin(&#x27;Github Search&#x27;, function suite(test) {\n    casper.start(&#x27;https:&#x2F;&#x2F;github.com&#x27;, function () {    &#x2F;&#x2F; 打开首页\n        test.assertVisible(&#x27;.js-site-search-form&#x27;, &#x27;should search input visible&#x27;);\n        this.fill(&#x27;.js-site-search-form&#x27;, { q: &#x27;casperjs&#x27; }, true); &#x2F;&#x2F; 键入搜索词、并提交\n    });\n\n    casper.then(function () {\n        test.assertEval(function() {    &#x2F;&#x2F; 确认搜索结果是 10\n            return __utils__.findAll(&#x27;.repo-list-item&#x27;).length &gt;= 10;\n        }, &#x27;should show 10 results&#x27;);\n    });\n\n    casper.then(function () {\n        this.click(&#x27;.repo-list-item h3 a&#x27;); &#x2F;&#x2F; 点击第1条结果\n    });\n\n    var location = null;\n\n    casper.then(function () {   &#x2F;&#x2F; 这里是取环境变量\n        test.assertVisible(&#x27;.repository-content&#x27;, &#x27;should repo detail visible&#x27;);\n        location = this.evaluate(function () {\n            return window.location;\n        });\n    });\n\n    casper.then(function () {   &#x2F;&#x2F; 确认目前跳转到了 casperjs 官方仓库\n        test.assertEquals(location.pathname, &#x27;&#x2F;casperjs&#x2F;casperjs&#x27;, &#x27;should casperjs repo found&#x27;);\n    });\n\n    casper.run(function () {\n        test.done();\n    });\n});\n</code></pre><p>因为 CasperJS 对 <a href=\"http://coffeescript.org/\">CoffeeScript</a> 有天然的支持，熟悉 CoffeeScript 的同学可以尝试使用 CoffeeScript 编写测试，或者使用<a href=\"https://devexpress.github.io/testcafe/documentation/test-api/assertions/\">这个工具</a>转换为 CoffeScript。</p>\n<h4>运行测试</h4>\n<pre class=\"prettyprint\"><code>casperjs test casperjs&#x2F;test.js\n</code></pre><h4>查看报告</h4>\n<p><strong>测试通过</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-6aabd0f83c67f3bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>测试失败</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-c4e5b15d70cdcb6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<h3>Protractor</h3>\n<p><a href=\"http://www.protractortest.org/\">Protractor</a> 是 <a href=\"https://angular.io/\">Angular</a> 官方正在使用的 E2E 测试框架，可以说是专门为 Angular 定制，内置了各种可以选择、操作 Angular 元素的便捷方法，如果你的应用基于 Angular 开发，使用它可以减少很多重复代码（显然类似的便利在其他框架中也有支持）。对于 Angular 的重度使用者，Protractor 会是非常明智的选择，不同于 CasperJS 的是 Protractor 在真实浏览器中运行测试代码。此外，Protractor 内置的页面加载等待的功能，在 CasperJS 中需要自己设置合理的超时。相比于本文列出的其他框架，Protractor 的明显优势是测试用例的组织方式可以自由使用 <a href=\"https://jasmine.github.io/\">Jasmine</a> 或者 <a href=\"https://mochajs.org/\">Mocha</a>。</p>\n<h4>安装步骤</h4>\n<ul>\n<li>安装 JDK</li>\n<li>安装 Protractor：<code>npm install –g protractor</code></li>\n<li>初始化 WebDriver Manager：<code>webdriver-manager update</code></li>\n<li><a href=\"https://github.com/angular/protractor/blob/master/lib/config.ts\">创建配置文件</a></li>\n</ul>\n<h4>编写测试</h4>\n<p>Protractor 默认开启了等待 Angular 加载并初始化完成的功能，如果你测试的不是 Angular 应用，则需要关闭这个功能，测试代码示例如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>describe(&#x27;angularjs homepage todo list&#x27;, function () {\n    browser.ignoreSynchronization = true;   &#x2F;&#x2F; 不启用智能等待，因为 github 不是用 angluar 编写的\n    browser.get(&#x27;https:&#x2F;&#x2F;github.com&#x27;);\n\n    it(&#x27;should search input visible&#x27;, function () {\n        var searchInput = element(by.className(&#x27;js-site-search-focus&#x27;));\n        var searchForm = element(by.className(&#x27;js-site-search-form&#x27;));\n        expect(searchInput.isDisplayed()).toEqual(true);\n        searchInput.sendKeys(&#x27;protractor&#x27;);\n        searchForm.submit();\n    });\n\n    it(&#x27;should show 10 results&#x27;, function () {\n        var searchList = element.all(by.className(&#x27;repo-list-item&#x27;));\n        expect(searchList.count()).toEqual(10);\n        element(by.css(&#x27;.repo-list-item h3 a&#x27;)).click();\n    });\n\n    it(&#x27;should repo detail visible&#x27;, function () {\n        var repoContent = element.all(by.className(&#x27;repository-content&#x27;));\n        expect(repoContent.isDisplayed()).toEqual([true]);\n    });\n\n    it(&#x27;should protractor repo found&#x27;, function (done) {\n        browser.executeScript(function () {\n            return window.location;\n        }).then(function (location) {\n            expect(location.pathname).toEqual(&#x27;&#x2F;angular&#x2F;protractor&#x27;);\n            done();\n        });\n    });\n});\n</code></pre><h4>运行测试</h4>\n<ul>\n<li>运行 WebDriver Manager: <code>webdriver-manager start</code></li>\n<li>运行测试：<code>protractor protractor.config.js</code></li>\n</ul>\n<h4>查看报告</h4>\n<p><strong>测试通过</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-146d85b08c04ff3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>测试失败</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-1425c11fb7d593fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<h3>Nightwatch</h3>\n<p>同样流行的 <a href=\"http://nightwatchjs.org/\">Nightwatch</a>，可以认为是 Protractor 的主要竞争对手，使用 Nigthwatch 编写的代码非常简洁，但是你需要手动在测试代码中添加合适的等待来保障测试的稳定，而 Protractor 和 TestCafe 则提供了内置的支持；Nightwatch 的主要劣势在于繁琐的安装步骤，可能部分同学看到这个<a href=\"http://nightwatchjs.org/gettingstarted#installation\">安装文档</a>或者下面的安装步骤就知难而退了。</p>\n<h4>安装步骤</h4>\n<ul>\n<li>安装 JDK，版本 7 以上</li>\n<li>下载 Selenium: <a href=\"http://selenium-release.storage.googleapis.com/index.html\">selenium-server-standalone-{VERSION}.jar</a>，复制到测试目录</li>\n<li>下载 <a href=\"https://sites.google.com/a/chromium.org/chromedriver/downloads\">WebDriver for Google Chrome</a>，复制到测试目录</li>\n<li>安装 Nightwatch: <code>npm install -g nightwatch</code></li>\n<li><a href=\"http://nightwatchjs.org/getingstarted\">创建配置文件</a>，需要在配置中声明 chromewebdriver 的地址；</li>\n</ul>\n<h4>编写测试</h4>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = {\n    &#x27;Github Search&#x27;: function (browser) {\n        browser &#x2F;&#x2F; 打开首页、填写搜索词、提交搜索表单\n            .url(&#x27;https:&#x2F;&#x2F;github.com&#x27;)\n            .assert.visible(&#x27;.js-site-search-focus&#x27;, &#x27;should search input visible&#x27;)\n            .setValue(&#x27;.js-site-search-focus&#x27;, &#x27;nightwatch&#x27;)\n            .submitForm(&#x27;.js-site-search-form&#x27;)\n            .pause(1000);\n\n        browser.execute(function () {   &#x2F;&#x2F; 确认展示 10 条搜索结果\n            return document.querySelectorAll(&#x27;.repo-list-item&#x27;).length;\n        }, function (args) {\n            browser.assert.equal(args.value, 10, &#x27;should show 10 results&#x27;);\n        });\n\n        browser.click(&#x27;.repo-list-item h3 a&#x27;).pause(1000);\n\n        browser.assert.visible(&#x27;.repository-content&#x27;, &#x27;should repo detail visible&#x27;);\n\n        browser.execute(function () {\n            return window.location;\n        }, function (args) {    &#x2F;&#x2F; 确认打开了 nightwatch 官网\n            browser.assert.equal(args.value.pathname, &#x27;&#x2F;nightwatchjs&#x2F;nightwatch&#x27;, &#x27;should nightwatch repo found&#x27;);\n        });\n\n        browser.end();\n    }\n};\n</code></pre><h4>运行测试</h4>\n<ul>\n<li>运行 Selenium：<code>java -jar selenium-server-standalone-3.0.0.jar</code></li>\n<li><code>nightwatch test.js</code></li>\n</ul>\n<h4>查看报告</h4>\n<p><strong>测试通过</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-c5477680f2fc9473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>测试失败</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-8b0dc9493a0a509e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<h3>TestCafe</h3>\n<p><a href=\"https://devexpress.github.io/testcafe/\">TestCafe</a> 是非常年轻但很受开发者欢迎的测试框架，因为不需要依赖 <a href=\"http://webdriver.io/\">WebDriver</a> 之类的东西，TestCafe 环境只需一键即可完成，这也意味着，你可以在任何安装了浏览器应用的物理设备上运行测试。TestCafe 对 ES6/ES7 语法的天然支持让它更具前瞻性，命令行工具产生的测试报告简洁但不失完整。由于开源的时间较短，相比于其他测试框架 TestCafe 的社区和生态还不够成熟。尽管如此，不断出现的各种 TestCafe 功能扩展也证明了它的社区和生态在不断壮大。对于站在 WEB 技术风口浪尖的同学，TestCafe 无疑是非常值得留意的 E2E 测试解决方案，开箱即用的特性极大的降低了使用者的成本。</p>\n<h4>安装步骤</h4>\n<p><code>npm install testcafe -g</code></p>\n<h4>编写测试</h4>\n<p>TestCafe 的测试组织方式详见<a href=\"http://devexpress.github.io/testcafe/documentation/test-api/test-code-structure.html\">这里</a>，<a href=\"https://devexpress.github.io/testcafe/documentation/test-api/selecting-page-elements/\">选择符支持</a>也非常强大，支持类似于 jQuery 的灵活异步的选择符，<a href=\"https://devexpress.github.io/testcafe/documentation/test-api/assertions/\">断言风格</a>非常类似 <a href=\"http://chaijs.com/\">Chai</a>，下面是测试代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>import { Selector } from &#x27;testcafe&#x27;;\n\nfixture &#96;Github Search&#96;\n    .page &#96;https:&#x2F;&#x2F;github.com&#96;;\n\ntest(&#x27;should github search work as expected&#x27;, async t =&gt; {\n    const searchInput = Selector(&#x27;.js-site-search-focus&#x27;);\n    const searchList = Selector(&#x27;.repo-list-item&#x27;);\n    const resultItem = Selector(&#x27;.repo-list-item h3 a&#x27;);\n    const repoContent = Selector(&#x27;.repository-content&#x27;);\n\n    await t.setTestSpeed(0.8);\n    await t.expect(searchInput.exists).eql(true, &#x27;should search input visible&#x27;);\n    await t.typeText(searchInput, &#x27;testcafe&#x27;);\n    await t.pressKey(&#x27;enter&#x27;);\n\n    await t.expect(searchList.count).eql(10, &#x27;should show 10 results&#x27;);\n    await t.click(resultItem);\n\n    await t.expect(repoContent.exists).eql(true, &#x27;should repo detail visible&#x27;);\n\n    const location = await t.eval(() =&gt; window.location);\n    await t.expect(location.pathname).eql(&#x27;&#x2F;DevExpress&#x2F;testcafe&#x27;, &#x27;should testcafe repo found&#x27;);\n});\n</code></pre><h4>运行测试</h4>\n<pre class=\"prettyprint\"><code>testcafe chrome testcafe&#x2F;test.js\n</code></pre><h4>查看报告</h4>\n<p><strong>测试通过</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-e60de6db859f5a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>测试失败</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-131ab3354d7912f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<h3>CodeceptJs</h3>\n<p><a href=\"http://codecept.io/\">CodeceptJs</a> 可能并不算是严格意义的 E2E 测试框架，它对各种测试运行工具做了一层封装，旨在提供更简洁的 API，你可以自由选择下面这些测试运行工具：</p>\n<ul>\n<li>WebDriverIO</li>\n<li>Protractor</li>\n<li>Selenium WebDriver JS</li>\n<li>NightmareJS</li>\n</ul>\n<p>CodeceptJs 让笔者比较欣赏的地方在于测试用例的组织，基于 <code>Feature</code> 和 <code>Scenario</code> 两个粒度来组织测试让它看起来更有 E2E 测试的样子，它支持最新的 ES6 语法，同时也屏蔽各种复杂的回调细节，所有的测试用例都是以第一人称来做，让测试代码阅读起来更像是自然语言，而让笔者担忧的地方在于，过多的封装可能导致出问题时排查比较困难。</p>\n<h4>安装步骤</h4>\n<ul>\n<li>安装 CodeceptJs <code>npm install -g codeceptjs</code></li>\n<li>用命令行工具初始化配置 <code>codecept.json</code>：<code>codeceptjs init</code></li>\n<li>使用命令行工具生成测试：<code>codeceptjs gt</code></li>\n<li>此外，你需要安装你所选择的底层测试工具，比如 WebDriver、Protractor</li>\n</ul>\n<h4>编写测试</h4>\n<pre class=\"prettyprint language-javascript\"><code>Feature(&#x27;Github Search&#x27;);\n\nScenario(&#x27;search codecept repo&#x27;, (I) =&gt; {\n    I.amOnPage(&#x27;https:&#x2F;&#x2F;github.com&#x27;);\n    I.seeElement(&#x27;.js-site-search-focus&#x27;);\n    I.fillField(&#x27;.js-site-search-focus&#x27;, &#x27;codeceptjs&#x27;);\n    I.pressKey(&#x27;Enter&#x27;);\n\n    I.seeElement(&#x27;.repo-list-item&#x27;);\n    I.click(&#x27;.repo-list-item h3 a&#x27;);\n    I.seeElement(&#x27;.repository-content&#x27;);\n    I.seeInCurrentUrl(&#x27;&#x2F;Codeception&#x2F;CodeceptJS&#x27;);\n});\n</code></pre><h4>运行测试</h4>\n<p><code>codeceptjs run</code></p>\n<h4>查看报告</h4>\n<p><strong>测试通过</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-7fad46a13b2a02ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>测试失败</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4651399-e7e8d9c85af26cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<h2>总结对比</h2>\n<p>本文中的所有代码可以在 GitHub <a href=\"https://github.com/wangshijun/top-5-e2e-framework\">仓库</a>上看到。任何开发工具的演化都是朝着更快捷、高效的目标。本文介绍的几个 E2E 测试框架可以说各有所长，在做框架选型的时候该考虑哪些因子呢？这些因子的优先级如何？下面是笔者的考虑：</p>\n<ul>\n<li>上手简单：P0，环境搭建步骤？出错的概率？是否需要繁琐的配置？TestCafe 非常简单；</li>\n<li>文档支持：P0，是否包含入门文档？API 参考？开发者文档？本文中的五款都还不错；</li>\n<li>过程透明：P0，测试运行过程是否是透明的，能否观察到页面行为？CasperJS 就像个黑盒；</li>\n<li>运行速度：P0，测试运行速度能决定你 CI 流程的好坏；</li>\n<li>测试报告：P0，是否支持多种报告？是否方便与 CI 流程集成？比如要支持 XML、JUnit 等格式输出；</li>\n<li>调试功能：P0，出错时提供的信息是否清晰？是否支持截图？TestCafe 做的很好；</li>\n<li>测试组织：P1，是否能与现有的技术栈很好的组合起来？不能结合独创的方式是否直观？如果是大型项目可以提高优先级，Protractor 和 CodeCeptJs 占优；</li>\n<li>代码风格：P1，简洁的代码意味的更高的可读性、更低的维护成本；TestCafe、CodeCeptJs 不错；</li>\n<li>社区支持：P2，围绕这个工具是否有成熟的社区？可以用来提问、贡献代码；</li>\n<li>可扩展性：P3，是否支持 API 扩展？扩展成本如何？</li>\n</ul>\n<p>如果你的项目中需要添加 E2E 测试，做决定的时候没有标准答案，因为还需要结合项目自身的特点，比如规模大小、对上面各因子的要求。</p>\n<p>备注：本文的初始版本来源于 Medium 上的<a href=\"https://medium.com/@adrian_lewis/top-5-most-rated-node-js-frameworks-for-end-to-end-web-testing-f8ebca4e5d44#.e03ky5jgy\">文章</a>，但是笔者在原文基础上重新设计了测试用例，每个测试框架的介绍也参与了笔者自身的使用经验，框架选型上也融入了自己的思考，有兴趣的可以去看原文。</p>\n<h2>One More Thing</h2>\n<p>本文首发<a href=\"https://zhuanlan.zhihu.com/feweekly\">知乎专栏</a>，商业转载请联系作者获得授权，非商业转载请注明出处。如果对文中的内容有任何疑问，欢迎留言讨论。想知道我接下来会写些什么？欢迎订阅知乎专栏：<a href=\"https://zhuanlan.zhihu.com/feweekly\">《前端周刊：让你在前端领域跟上时代的脚步》</a>。</p>\n</div>",
		"title": "最受欢迎的 5 款 Node.js 端到端测试框架",
		"last_reply_at": "2017-04-01T03:07:33.365Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 161,
		"create_at": "2017-03-31T23:22:19.943Z",
		"author": {
			"loginname": "wangshijun",
			"avatar_url": "https://avatars3.githubusercontent.com/u/719985?v=3&s=120"
		}
	}, {
		"id": "58d73f51e9ab80d02d37708f",
		"author_id": "5875a4e906fa6e2a4e4f72f3",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>log4js.fileAppender - Writing to file log_file.log, error happened  { Error: EMFILE: too many  open files, open ‘log_file.log’</p>\n</blockquote>\n</div>",
		"title": "有人遇到过log4js的Error: EMFILE: too many  open files问题吗？",
		"last_reply_at": "2017-04-01T03:00:55.170Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 248,
		"create_at": "2017-03-26T04:10:57.930Z",
		"author": {
			"loginname": "jeeinn",
			"avatar_url": "https://avatars1.githubusercontent.com/u/13930054?v=3&s=120"
		}
	}, {
		"id": "54c071c408db81d71f316278",
		"author_id": "544f5059888fcbd6172d38cf",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>我的项目使用了pm2部署</p>\n<pre class=\"prettyprint\"><code>pm2 start .&#x2F;bin&#x2F;www -i 0\n</code></pre><p>启动项目，正常访问</p>\n<p>然后如果使用了\n\t\tpm2 restart all\n或者\n\t\tpm2 reload all</p>\n<p>则页面无法访问，一直处于连接等待状态然后超时</p>\n<p>求教高手</p>\n</div>",
		"title": "Pm2 使用过程中遇到的问题，无法reload restart",
		"last_reply_at": "2017-04-01T02:38:05.721Z",
		"good": false,
		"top": false,
		"reply_count": 20,
		"visit_count": 6122,
		"create_at": "2015-01-22T03:43:00.001Z",
		"author": {
			"loginname": "skipify",
			"avatar_url": "https://avatars.githubusercontent.com/u/1555505?v=3&s=120"
		}
	}, {
		"id": "58d33f6ef7abd67436265cfd",
		"author_id": "5679f640a056d34607805737",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fteb3ArhZhpPZcirkrPM3as4V-dT\" alt=\"untitled1.png\">\n<img src=\"//dn-cnode.qbox.me/FnmiL8krPuwtBx0kgxF-gYUuoJHy\" alt=\"untitled2.png\">\n成功运行了但是控制台无返回什么原因？</p>\n</div>",
		"title": "使用child_process调用批处理文件无返回结果？",
		"last_reply_at": "2017-04-01T02:22:46.855Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 347,
		"create_at": "2017-03-23T03:22:22.931Z",
		"author": {
			"loginname": "muzi-xiangxiang",
			"avatar_url": "https://avatars2.githubusercontent.com/u/16145343?v=3&s=120"
		}
	}, {
		"id": "58ddf2cae9ab80d02d377230",
		"author_id": "5747b26b754d17df1e44da80",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FmbcwvNFJxtrIQaUo6R7o3mLAHlG\" alt=\"QQ图片20170331140814.png\"></p>\n<p>==这样就给了test账号test库和testRO库的权限,为什么在testRO库里不能通过auth()\n?在test库里可以通过.==</p>\n</div>",
		"title": "mongoDB管理账户的小问题",
		"last_reply_at": "2017-04-01T02:21:47.738Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 149,
		"create_at": "2017-03-31T06:10:18.906Z",
		"author": {
			"loginname": "hyper-god",
			"avatar_url": "https://avatars.githubusercontent.com/u/19601087?v=3&s=120"
		}
	}, {
		"id": "58df0684e9ab80d02d377264",
		"author_id": "58df0636e9ab80d02d377263",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h1>webpack-vue-demo</h1>\n<p>webpack+vue+vueRouter+es6 构建的简单实例项目</p>\n<blockquote>\n<p>github地址 <a href=\"https://github.com/193Eric/webpack-vue-vueRouter\">https://github.com/193Eric/webpack-vue-vueRouter</a></p>\n</blockquote>\n<p>Vue很轻量，它写组件的方式非常舒服。代码风格也很干净。之前也在网上看了很多案例，知道入门的时候很麻烦，特别是webpack+vue的使用。\n所以我用Vue写了一个小demo（适合初学者的）</p>\n<p>项目很小，麻雀虽小，五脏俱全。\n对初学者不知道怎么构建项目很有帮助。\n第一次在社区发帖，希望各位大大多多指导。（~~~~）</p>\n<h5>演示效果</h5>\n<hr>\n<p><img src=\"//dn-cnode.qbox.me/Fr02XrtH4tCezHBs48AOkRYW4OrX\" alt=\"pig.gif\"></p>\n<hr>\n<h5>环境</h5>\n<ol>\n<li>node v6.10.1</li>\n<li>cnpm 4.5.0</li>\n<li>npm 3.10.10</li>\n</ol>\n<h5>技术栈</h5>\n<blockquote>\n<p>[vue]</p>\n</blockquote>\n<blockquote>\n<p>[vue-router]</p>\n</blockquote>\n<blockquote>\n<p>[vue-resource]</p>\n</blockquote>\n<blockquote>\n<p>[webpack]</p>\n</blockquote>\n<blockquote>\n<p>[es6-babel]</p>\n</blockquote>\n<blockquote>\n<p>[less]</p>\n</blockquote>\n<h3>目录结构</h3>\n<p>&lt;pre&gt;\n.\n├── <a href=\"http://README.md\">README.md</a><br>\n├── dist                     // 项目build目录\n├── package.json             // 项目配置文件\n├── src                      // 生产目录\n│   ├── assets               // css js 和图片资源\n│   ├── components           // 各种组件\n│   ├── views                // 各种页面\n│   ├── router.js            // 路由配置\n│   └── app.vue              // 根组件\n│   └── main.js              // Webpack 预编译入口<br>\n├── index.html               // 项目入口文件\n├── webpack.config.js        //webpack配置文件\n├── .gitignore               //git忽略文件\n&lt;/pre&gt;</p>\n<h3>安装</h3>\n<p>项目地址：（使用<code>git clone</code>）</p>\n<pre class=\"prettyprint language-shell\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;193Eric&#x2F;webpack-vue-vueRouter.git\n</code></pre><p>通过<code>npm</code>安装本地服务第三方依赖模块(需要已安装<a href=\"https://nodejs.org/\">Node.js</a>)，使用npm安装依赖模块可能会很慢，建议换成<a href=\"http://cnpmjs.org/\">cnpm</a></p>\n<pre class=\"prettyprint language-shell\"><code>npm install -g cnpm --registry=http:&#x2F;&#x2F;registry.npm.taobao.org\n</code></pre><pre class=\"prettyprint language-bash\"><code># 安装依赖模块\ncnpm install\n\nnpm run build\n\nnpm run dev\n\n\n然后会自动弹出浏览器地址 http:&#x2F;&#x2F;localhost:8081</code></pre></div>",
		"title": "webpack+vue+vueRouter+es6 构建的简单实例项目",
		"last_reply_at": "2017-04-01T01:46:44.501Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 155,
		"create_at": "2017-04-01T01:46:44.501Z",
		"author": {
			"loginname": "193Eric",
			"avatar_url": "https://avatars1.githubusercontent.com/u/20290762?v=3&s=120"
		}
	}, {
		"id": "58d4b894b3e60b982d089b36",
		"author_id": "56ce68bc842c03521a73520e",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>我自己用mongodb做了有大小上十个项目了，使用时有些不好的体验总结如下：</p>\n<ol>\n<li>mongodb对关联操作（类似Mysql的join）支持不够好<br>\n2.事务场景很难处理<br>\n3.好像没有了<br>\n遇到这两个问题时，总会想起Mysql，但是已经Mongodb已经用了很久了，总是下不了决心去换。<br>\n这里希望大家讲讲nodejs项目中使用Mysql的体验如何，帮我做个决定。</li>\n</ol>\n</div>",
		"title": "大家觉得nodejs项目，数据库用Mongodb好，还是Mysql好？",
		"last_reply_at": "2017-04-01T01:07:13.253Z",
		"good": false,
		"top": false,
		"reply_count": 24,
		"visit_count": 947,
		"create_at": "2017-03-24T06:11:32.280Z",
		"author": {
			"loginname": "qujinxiong",
			"avatar_url": "https://avatars2.githubusercontent.com/u/15104950?v=3&s=120"
		}
	}, {
		"id": "55f673920209f4f25879f418",
		"author_id": "533e230b9ac9b5890d0236f7",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://code.visualstudio.com/\">visual studio code</a>（以下简称<code>vsc</code>）最近更新到了<code>0.8.0</code>版本，新加的一些特性都很nice。多了几个配色方案（流行的<code>monokai</code>配色也有了，虽然效果并不好），也支持自定义安装目录了。最让我感动的是对<code>jsx</code>文件做了语法高亮，写<code>react</code>的时候再也不是一片黑色了。</p>\n<p>今天来了兴致，推荐一下，希望有更多的同学来使用这个编辑器。</p>\n<h3>介绍</h3>\n<p><code>vsc</code>的宣传语是：</p>\n<blockquote>\n<p>一个运行于 <code>Mac OS X</code>、<code>Windows</code>和 <code>Linux</code> 之上的，针对于编写现代 <code>Web</code> 和云应用的跨平台源代码编辑器。</p>\n</blockquote>\n<p>按它说的，<code>vsc</code>特别适合来作为前端开发编辑器。</p>\n<p>内置<code>html</code>开发神器<code>emmet</code>(<code>zencoding</code>),对<code>css</code>及其相关编译型语言<code>Less</code>和<code>Sass</code>都有很好的支持。</p>\n<p>当然，最nice的还是写<code>js</code>代码了，这也是我接下来要着重介绍的功能。</p>\n<h3>智能提示</h3>\n<p>因为之前微软推出了<a href=\"http://www.typescriptlang.org/\">typescript</a>语言，结合<code>tsd</code>文件，用<code>visual studio</code>写<code>typescript</code>代码是相当爽的，智能提示的功能非常<code>nb</code>。</p>\n<p>这个功能理所应当也被<code>vsc</code>继承了。</p>\n<p>目前主流的前端类库/框架，包括<code>node.js</code>及其模块/框架都有相应的<code>tsd</code>文件，可以去<a href=\"https://github.com/borisyankov/DefinitelyTyped\">DefinitelyTyped</a>上找一下。</p>\n<p>在项目中引入对应文件，就可以有智能提示了。</p>\n<p>这里以<code>angular</code>为例，使用步骤如下：</p>\n<ol>\n<li>全局安装<code>tsd</code>，通过<code>tsd</code>安装<code>.d.ts</code>文件。这样会在项目下面生成<code>.typings</code>目录，目录下面就是下载的<code>.d.ts</code>文件，再写代码的时候就会有智能提示了。具体用法参考<a href=\"https://github.com/DefinitelyTyped/tsd\">tsd用法</a>。</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>npm install -g tsd\n\ntsd query angular --action install\n\n</code></pre><ol>\n<li>如果不想自己手工引入，也可以在<code>angular</code>变量后面按<code>ctrl+k</code>，会有个灯泡图片，点击灯泡图片就会有对应提示，选择下载<code>xx.d.ts</code>文件就可以了,编辑器会下载对应文件放在<code>.typings</code>目录。</li>\n</ol>\n<p>过程如下图：</p>\n<p><img src=\"http://segmentfault.com/img/bVpQoi/view\" alt=\"图片描述\"></p>\n<p>再来个<code>node.js</code>的：</p>\n<p><img src=\"http://segmentfault.com/img/bVpQoj/view\" alt=\"图片描述\"></p>\n<p>说完智能提示，再说代码调试。</p>\n<h3>调试Node</h3>\n<p>之前写过文章介绍过<code>node.js</code>的调试方案（<a href=\"http://segmentfault.com/a/1190000002542114\">Node.js调试</a>）。从<code>vsc</code>发布后，我就一直用它写代码，也是用它来调试<code>node.js</code>代码。</p>\n<p>使用方法也很简单,步骤如下：</p>\n<ol>\n<li>打开要调试的文件，按<code>f5</code>,编辑器会生成一个<code>launch.json</code></li>\n<li>修改<code>launch.json</code>相关内容，主要是<code>name</code>和<code>program</code>字段，改成和你项目对应的</li>\n<li>点击编辑器左侧长得像蜘蛛的那个按钮</li>\n<li>点击左上角<code>DEBUG</code>后面的按钮，启动调试</li>\n<li>打断点，尽情调试</li>\n</ol>\n<p>过程如下图：\n<img src=\"http://segmentfault.com/img/bVpQol/view\" alt=\"图片描述\"></p>\n<p>最后，再赠送彩蛋一个。</p>\n<h3>Node API 查看</h3>\n<p>在写<code>node.js</code>代码的时候，有时会忘记某个模块中有哪些方法及其用法，经常要去官网翻一下<code>api</code>文档。</p>\n<p>这里介绍下怎么使用<code>vsc</code>来搞定这一问题。</p>\n<ol>\n<li>打开<code>vsc</code>控制台（<code>Help &gt; Toggle Developer Tools &gt; Console</code>）</li>\n<li>在控制台写代码，查询模块方法。</li>\n</ol>\n<p>过程如下图：\n<img src=\"http://segmentfault.com/img/bVpQom/view\" alt=\"图片描述\"></p>\n<p><code>vsc</code>是用<code>atom-shell</code>(现在叫<a href=\"http://electron.atom.io/\">electron</a>)写的，这玩意和<code>node-webkit</code>（现在叫<a href=\"http://nwjs.io/\">nw.js</a>）一样，都是把<code>node.js</code>和<code>chrome</code>结合起来的工具，所以可以这么使用。</p>\n<p>不过<code>vsc</code>使用到的<code>node.js</code>模块并不多，比如引用<code>util</code>和<code>vm</code>等会报错，用<code>node-webkit</code>就不会这样。</p>\n<h3>结语</h3>\n<p><code>vsc</code>和其他编辑器（<code>sublime text</code>,<code>atom</code>,<code>webstorm</code>等）相比，某些方面还存在很多问题。对于一个前端工程师来说，它已经足够好了。</p>\n<p>当然了，它在不断改进。等着它支持插件系统，支持<code>vim</code>模式。</p>\n</div>",
		"title": "用Visual Studio Code写Node.js",
		"last_reply_at": "2017-03-31T14:22:34.322Z",
		"good": true,
		"top": false,
		"reply_count": 29,
		"visit_count": 30046,
		"create_at": "2015-09-14T07:13:22.537Z",
		"author": {
			"loginname": "hellopao",
			"avatar_url": "https://avatars.githubusercontent.com/u/5064875?v=3&s=120"
		}
	}, {
		"id": "58de104f03d476b42d34c92d",
		"author_id": "58da0587b3e60b982d089c60",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里这是一个测试标题尽量把话题要点浓缩到标题里\n测试</p>\n</div>",
		"title": "这是一个测试标题尽量把话题要点浓缩到标题里",
		"last_reply_at": "2017-03-31T12:39:03.815Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 140,
		"create_at": "2017-03-31T08:16:15.451Z",
		"author": {
			"loginname": "niices",
			"avatar_url": "https://avatars3.githubusercontent.com/u/8327775?v=3&s=120"
		}
	}, {
		"id": "58ddc167e9ab80d02d377215",
		"author_id": "58ddc0ea6f8b9bf02d1d0c95",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FuvFsz81UFYRVuz6DQhczaarHlVP\" alt=\"B2AAE45B-0896-4CCF-97FE-837979C513FC.png\"></p>\n</div>",
		"title": "Mac下用WebStorm创建Node项目出错！",
		"last_reply_at": "2017-03-31T11:17:25.774Z",
		"good": false,
		"top": false,
		"reply_count": 10,
		"visit_count": 243,
		"create_at": "2017-03-31T02:39:35.426Z",
		"author": {
			"loginname": "jiasongs",
			"avatar_url": "https://avatars0.githubusercontent.com/u/22904757?v=3&s=120"
		}
	}, {
		"id": "58d2297417f61387400b7e74",
		"author_id": "53d8bc0158cac41671987356",
		"tab": "job",
		"content": "<div class=\"markdown-text\"><h1>公司介绍</h1>\n<p>我们是一个初创公司，咔咔买房是我们的产品，我们致力于通过区块链电子产权证的方式提高不动产的流动性。16年年底获得了李笑来和百度七剑之一的王啸天使投资。希望在17年一起实现一个小目标！</p>\n<h1>职位描述</h1>\n<p>基本要求：\n1.熟练掌js语言特性,闭包规范，ES6标准；\n2.两年以上的node.js实际项目经验，熟练掌握express框架，了解node.js最佳实践；\n3.理解面向对像，设计模式，分层架构；\n4.编码习惯规范，理解软件工程，敏捷开发等工程管理理念；\n5.基本的英文文档阅读能力；\n6.自学能力较强</p>\n<p>加分项\n1.有过一种后端语言C#/PHP/JAVA的实践经验；\n2.有过一种前端框架(anuglar/vue/react ) 的实践经验；\n3.github 开源项目贡献；\n4.熟悉区块链或加密算法;\n5.熟悉以太坊智能合约；</p>\n<h1>薪资</h1>\n<p>15k+，不封顶</p>\n<h1>福利</h1>\n<p>五险一金,团建,奖金,年假,期权,该有的都有:)\nP.S. 我们的目标是让每一个员工都能在北京买房</p>\n<h1>联系方式</h1>\n<p><a href=\"mailto:hr@kakamf.com\">hr@kakamf.com</a></p>\n<p>#另外，我们也在招聘前端，靠谱的前端快快跳到碗里来哟</p>\n</div>",
		"title": "［北京．三元桥］　咔咔买房招聘node.js攻城狮２名，前端一名，期权，15k+，MBP+DELL24\"",
		"last_reply_at": "2017-03-31T10:58:01.508Z",
		"good": false,
		"top": false,
		"reply_count": 13,
		"visit_count": 344,
		"create_at": "2017-03-22T07:36:20.715Z",
		"author": {
			"loginname": "xuyangcn",
			"avatar_url": "https://avatars2.githubusercontent.com/u/2360775?v=3&s=120"
		}
	}, {
		"id": "504b4924e2b84515770103dd",
		"author_id": "4fbb004ad46624c476096875",
		"content": "<div class=\"markdown-text\"><h2>Mongoose学习参考文档</h2>\n<p><strong>前言</strong>：本学习参考文档仅供参考，如有问题，师请雅正</p>\n<p>##一、快速通道</p>\n<p>###1.1 名词解释</p>\n<ul>\n<li>\n<p><code>Schema</code>  ：  一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力</p>\n</li>\n<li>\n<p><code>Model</code>   ：  由<code>Schema</code>发布生成的模型，具有抽象属性和行为的数据库操作对</p>\n</li>\n<li>\n<p><code>Entity</code>  ：  由<code>Model</code>创建的实体，他的操作也会影响数据库</p>\n</li>\n</ul>\n<p><strong>注意</strong>：</p>\n<p>1.本学习文档采用严格命名方式来区别不同对象，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonSchema;   &#x2F;&#x2F;Person的文本属性\n    var PersonModel;    &#x2F;&#x2F;Person的数据库模型\n    var PersonEntity;   &#x2F;&#x2F;Person实体\n</code></pre><p>2.<code>Schema</code>、<code>Model</code>、<code>Entity</code>的关系请牢记，<code>Schema</code>生成<code>Model</code>，<code>Model</code>创造<code>Entity</code>，<code>Model</code>和<code>Entity</code>都可对数据库操作造成影响，但<code>Model</code>比<code>Entity</code>更具操作性。</p>\n<p>##1.2 准备工作</p>\n<p>1.首先你必须安装<a href=\"http://www.mongodb.org/\">MongoDB</a>和<a href=\"http://nodejs.org/\">NodeJS</a></p>\n<p>2.在项目只能够创建一个数据库连接，如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>    var mongoose = require(&#x27;mongoose&#x27;);    &#x2F;&#x2F;引用mongoose模块\n    var db = mongoose.createConnection(&#x27;localhost&#x27;,&#x27;test&#x27;); &#x2F;&#x2F;创建一个数据库连接\n</code></pre><p>3.打开本机<code>localhost</code>的<code>test</code>数据库时，我们可以监测是否有异常</p>\n<pre class=\"prettyprint language-javascript\"><code>    db.on(&#x27;error&#x27;,console.error.bind(console,&#x27;连接错误:&#x27;));\n    db.once(&#x27;open&#x27;,function(){\n      &#x2F;&#x2F;一次打开记录\n    });\n</code></pre><p><strong>注意</strong>：</p>\n<p>成功开启数据库后，就可以执行数据库相应操作，假设以下代码都在回调中处理</p>\n<p>4.定义一个<code>Schema</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonSchema = new mongoose.Schema({\n      name:String   &#x2F;&#x2F;定义一个属性name，类型为String\n    });\n</code></pre><p>5.将该<code>Schema</code>发布为<code>Model</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonModel = db.model(&#x27;Person&#x27;,PersonSchema);\n    &#x2F;&#x2F;如果该Model已经发布，则可以直接通过名字索引到，如下：\n    &#x2F;&#x2F;var PersonModel = db.model(&#x27;Person&#x27;);\n    &#x2F;&#x2F;如果没有发布，上一段代码将会异常\n</code></pre><p>6.用<code>Model</code>创建<code>Entity</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    var personEntity = new PersonModel({name:&#x27;Krouky&#x27;});\n    &#x2F;&#x2F;打印这个实体的名字看看\n    console.log(personEntity.name); &#x2F;&#x2F;Krouky\n</code></pre><p>7.我们甚至可以为此<code>Schema</code>创建方法</p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F;为Schema模型追加speak方法\n    PersonSchema.methos.speak = function(){\n      console.log(&#x27;我的名字叫&#x27;+this.name);\n    }\n    var PersonModel = db.model(&#x27;Person&#x27;,PersonSchema);\n    var personEntity = new PersonModel({name:&#x27;Krouky&#x27;});\n    personEntity.speak();&#x2F;&#x2F;我的名字叫Krouky\n</code></pre><p>8.<code>Entity</code>是具有具体的数据库操作<code>CRUD</code>的</p>\n<pre class=\"prettyprint language-javascript\"><code>    personEntity.save();  &#x2F;&#x2F;执行完成后，数据库就有该数据了\n</code></pre><p>9.如果要执行查询，需要依赖<code>Model</code>，当然<code>Entity</code>也是可以做到的</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonModel.find(function(err,persons){\n      &#x2F;&#x2F;查询到的所有person\n    });\n</code></pre><p><strong>注意</strong>：</p>\n<p>1. 具体的如何配置<code>Schema</code>、<code>Model</code>以及<code>Model</code>和<code>Entity</code>的相关操作，我们会在后面进行</p>\n<p>2. <code>Model</code>和<code>Entity</code>都有能影响数据库的操作，但仍有区别，后面我们也会做解释</p>\n<p>##二、新手指引</p>\n<p><em>如果您还不清楚<code>Mongoose</code>是如何工作的，请参看第一章快速通道快速浏览他的用法吧</em></p>\n<p>###1. Schema——纯洁的数据库原型</p>\n<p>####1.1 什么是Schema</p>\n<ul>\n<li>我理解<code>Schema</code>仅仅只是一断代码，他书写完成后程序依然无法使用，更无法通往数据库端</li>\n<li>他仅仅只是数据库模型在程序片段中的一种表现，或者是数据属性模型</li>\n</ul>\n<p>####1.2 如何定义Schema</p>\n<pre class=\"prettyprint language-javascript\"><code>    var BlogSchema = new Schema({\n      title:String,\n      author:String\n      &#x2F;&#x2F;new Schema()中传入一个JSON对象，该对象形如 xxx:yyyy ,\n      &#x2F;xxx是一个字符串，定义了属性，yyy是一个Schema.Type，定义了属性类型\n    });\n</code></pre><p>####1.3 什么是Schema.Type</p>\n<p><code>Schema.Type</code>是由<code>Mongoose</code>内定的一些数据类型，基本数据类型都在其中，他也内置了一些<code>Mongoose</code>特有的<code>Schema.Type</code>。当然，你也可以自定义<code>Schema.Type</code>，只有满足<code>Schema.Type</code>的类型才能定义在<code>Schema</code>内。</p>\n<p>####1.4 Schema.Types</p>\n<p><code>NodeJS</code>中的基本数据类型都属于<code>Schema.Type</code>，另外<code>Mongoose</code>还定义了自己的类型</p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F;举例：\n    var ExampleSchema = new Schema({\n      name:String,\n      binary:Buffer,\n      living:Boolean,\n      updated:Date,\n      age:Number,\n      mixed:Schema.Types.Mixed, &#x2F;&#x2F;该混合类型等同于nested\n      _id:Schema.Types.ObjectId,  &#x2F;&#x2F;主键\n      _fk:Schema.Types.ObjectId,  &#x2F;&#x2F;外键\n      array:[],\n      arrOfString:[String],\n      arrOfNumber:[Number],\n      arrOfDate:[Date],\n      arrOfBuffer:[Buffer],\n      arrOfBoolean:[Boolean],\n      arrOfMixed:[Schema.Types.Mixed],\n      arrOfObjectId:[Schema.Types.ObjectId]\n      nested:{\n        stuff:String,\n      }\n    });\n</code></pre><p>####1.5 关于Buffer</p>\n<p><code>Buffer</code>和<code>ArrayBuffer</code>是<code>Nodejs</code>两种隐藏的对象，相关内容请查看<code>NodeJS-API</code></p>\n<p>####1.6 关于Mixed</p>\n<p><code>Schema.Types.Mixed</code>是<code>Mongoose</code>定义个混合类型，该混合类型如果未定义具体形式。因此,如果定义具体内容，就直接使用<code>{}</code>来定义，以下两句等价</p>\n<pre class=\"prettyprint language-javascript\"><code>    var AnySchema = new Schema({any:{}});\n    var AnySchema = new Schema({any:Schema.Types.Mixed});\n</code></pre><p>混合类型因为没有特定约束，因此可以任意修改，一旦修改了原型，则必须调用<code>markModified()</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    person.anything = {x:[3,4,{y:&#x27;change&#x27;}]}\n    person.markModified(&#x27;anything&#x27;);&#x2F;&#x2F;传入anything，表示该属性类型发生变化\n    person.save();\n</code></pre><p>####1.7 关于ObjectId</p>\n<p>主键，一种特殊而且非常重要的类型，每个<code>Schema</code>都会默认配置这个属性，属性名为<code>_id</code>，除非自己定义，方可覆盖</p>\n<pre class=\"prettyprint language-javascript\"><code>    var mongoose = require(&#x27;mongoose&#x27;);\n    var ObjectId = mongoose.Schema.Types.ObjectId;\n    var StudentSchema = new Schema({}); &#x2F;&#x2F;默认会有_id:ObjectId\n    var TeacherSchema = new Schema({id:ObjectId});&#x2F;&#x2F;只有id:ObjectId\n</code></pre><p>该类型的值由系统自己生成，从某种意义上几乎不会重复，生成过程比较复杂，有兴趣的朋友可以查看源码。</p>\n<p>####1.8 关于Array</p>\n<p><code>Array</code>在<code>JavaScript</code>编程语言中并不是数组，而是集合，因此里面可以存入不同的值，以下代码等价：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ExampleSchema1 = new Schema({array:[]});\n    var ExampleSchema2 = new Schema({array:Array});\n    var ExampleSchema3 = new Schema({array:[Schema.Types.Mixed]});\n    var ExampleSchema4 = new Schema({array:[{}]});\n</code></pre><p>####1.9 附言</p>\n<p><code>Schema</code>不仅定义了<code>文档结构</code>和<code>使用性能</code>，还可以有<code>扩展插件</code>、<code>实例方法</code>、<code>静态方法</code>、<code>复合索引</code>、<code>文档生命周期钩子</code></p>\n<p><code>Schema</code>可以定义插件，并且插件具有良好的可拔插性，请有兴趣的读者继续往后阅读或者查阅官方资料。</p>\n<p>###2. Schema的扩展</p>\n<p>####2.1 实例方法</p>\n<p>有的时候，我们创造的<code>Schema</code>不仅要为后面的<code>Model</code>和<code>Entity</code>提供公共的属性，还要提供公共的方法。</p>\n<p>下面例子比快速通道的例子更加高级，可以进行高级扩展：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonSchema = new Schema({name:String,type:String});\n    &#x2F;&#x2F;查询类似数据\n    PersonSchema.methods.findSimilarTypes = function(cb){\n      return this.model(&#x27;Person&#x27;).find({type:this.type},cb);\n    }\n</code></pre><p>使用如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonModel = mongoose.model(&#x27;Person&#x27;,PersonSchema);\n    var krouky = new PersonSchema({name:&#x27;krouky&#x27;,type:&#x27;前端工程师&#x27;});\n    krouky.findSimilarTypes(function(err,persons){\n      &#x2F;&#x2F;persons中就能查询到其他前端工程师\n    });\n</code></pre><p>####2.2 静态方法</p>\n<p>静态方法在<code>Model</code>层就能使用，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>  PersonSchema.statics.findByName = function(name,cb){\n    this.find({name:new RegExp(name,&#x27;i&#x27;),cb});\n  }\n  var PersonModel = mongoose.model(&#x27;Person&#x27;,PersonSchema);\n  PersonModel.findByName(&#x27;krouky&#x27;,function(err,persons){\n    &#x2F;&#x2F;找到所有名字叫krouky的人\n  });\n</code></pre><p>####2.3 索引</p>\n<p>索引或者复合索引能让搜索更加高效，默认索引就是主键索引<code>ObjectId</code>，属性名为<code>_id</code>， <em>索引会作为一个专题来讲解</em></p>\n<p>####2.4 虚拟属性</p>\n<p><code>Schema</code>中如果定义了虚拟属性，那么该属性将不写入数据库，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonSchema = new Schema({\n      name:{\n        first:String,\n        last:String\n      }\n    });\n    var PersonModel = mongoose.model(&#x27;Person&#x27;,PersonSchema);\n    var krouky = new PersonModel({\n      name:{first:&#x27;krouky&#x27;,last:&#x27;han&#x27;}\n    });\n</code></pre><p>如果每次想使用全名就得这样</p>\n<pre class=\"prettyprint language-javascript\"><code>    console.log(krouky.name.first + &#x27; &#x27; + krouky.name.last);\n</code></pre><p>显然这是很麻烦的，我们可以定义<code>虚拟属性</code>：</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonSchema.virtual(&#x27;name.full&#x27;).get(function(){\n      return this.name.first + &#x27; &#x27; + this.name.last;\n    });\n</code></pre><p>那么就能用<code>krouky.name.full</code>来调用全名了，反之如果知道full，也可以反解<code>first</code>和<code>last</code>属性</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonSchema.virtual(&#x27;name.full&#x27;).set(function(name){\n      var split = name.split(&#x27; &#x27;);\n      this.name.first = split[0];\n      this.name.last = split[1];\n    });\n    var PersonModel = mongoose.model(&#x27;Person&#x27;,PersonSchema);\n    var krouky = new PersonModel({});\n    krouky.name.full = &#x27;krouky han&#x27;;&#x2F;&#x2F;会被自动分解\n    console.log(krouky.name.first);&#x2F;&#x2F;krouky\n</code></pre><p>####2.5 配置项</p>\n<p>在使用<code>new Schema(config)</code>时，我们可以追加一个参数<code>options</code>来配置<code>Schema</code>的配置，形如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ExampleSchema = new Schema(config,options);\n</code></pre><p>或者使用</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ExampleSchema = new Schema(config);\n    ExampleSchema.set(option,value);\n</code></pre><p>可供配置项有：<code>safe</code>、<code>strict</code>、<code>capped</code>、<code>versionKey</code>、<code>autoIndex</code></p>\n<p>#####2.5.1 safe——安全属性（默认安全）</p>\n<p>一般可做如下配置：</p>\n<pre class=\"prettyprint language-javascript\"><code>    new Schema({...},{safe:true});\n</code></pre><p>当然我们也可以这样</p>\n<pre class=\"prettyprint language-javascript\"><code>    new Schema({...},{safe:{j:1,w:2,wtimeout:10000}});\n</code></pre><p><code>j</code>表示做1份日志，<code>w</code>表示做2个副本（尚不明确），超时时间10秒</p>\n<p>#####2.5.2 strict——严格配置（默认启用）</p>\n<p>确保<code>Entity</code>的值存入数据库前会被自动验证，如果你没有充足的理由，请不要停用，例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ThingSchema = new Schema({a:String});\n    var ThingModel = db.model(&#x27;Thing&#x27;,SchemaSchema);\n    var thing = new Thing({iAmNotInTheThingSchema:true});\n    thing.save();&#x2F;&#x2F;iAmNotInTheThingSchema这个属性将无法被存储\n</code></pre><p>如果取消严格选项，<code>iAmNotInTheThingSchema</code>将会被存入数据库</p>\n<p>该选项也可以在构造实例时使用，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ThingModel = db.model(&#x27;Thing&#x27;);\n    var thing1 = new ThingModel(doc,true);  &#x2F;&#x2F;启用严格\n    var thing2 = new ThingModel(doc,false); &#x2F;&#x2F;禁用严格\n</code></pre><p><strong>注意：</strong></p>\n<p><code>strict</code>也可以设置为<code>throw</code>，表示出现问题将会抛出错误</p>\n<p>#####2.5.3 shardKey</p>\n<p>需要<code>mongodb</code>做分布式，才会使用该属性</p>\n<p>#####2.5.4 capped——上限设置</p>\n<p>如果有数据库的批量操作，该属性能限制一次操作的量，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    new Schema({...},{capped:1024});  &#x2F;&#x2F;一次操作上线1024条数据\n</code></pre><p>当然该参数也可是JSON对象，包含size、max、autiIndexId属性</p>\n<pre class=\"prettyprint language-javascript\"><code>    new Schema({...},{capped:{size:1024,max:100,autoIndexId:true}});\n</code></pre><p>#####2.5.5 versionKey——版本锁</p>\n<p>版本锁是<code>Mongoose</code>默认配置（__v属性）的，如果你想自己定制，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>    new Schema({...},{versionKey:&#x27;__someElse&#x27;});\n</code></pre><p>此时存入数据库的版本锁就不是<code>__v</code>属性，而是<code>__someElse</code>，相当于是给版本锁取名字。</p>\n<p>具体怎么存入都是由<code>Mongoose</code>和<code>MongoDB</code>自己决定，当然，这个属性你也可以去除</p>\n<pre class=\"prettyprint language-javascript\"><code>  new Schema({...},{versionKey:false});\n</code></pre><p>除非你知道你在做什么，并且你知道这样做的后果</p>\n<p>#####2.5.6 autoIndex——自动索引</p>\n<p><em>该内容将在索引章节单独讲解</em></p>\n<p>###3. Documents</p>\n<p><code>Document</code>是与<code>MongoDB</code>文档一一对应的模型，<code>Document</code>可等同于<code>Entity</code>，具有属性和操作性</p>\n<p><strong>注意：</strong></p>\n<p><code>Document</code>的`CRUD都必须经过严格验证的，参看<strong>2.5.2 Schema的strict严格配置</strong></p>\n<p>####3.1 查询</p>\n<p>查询内容过多，专题讲解</p>\n<p>####3.2 更新</p>\n<p>有许多方式来更新文件，以下是常用的传统方式：</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonModel.findById(id,function(err,person){\n      person.name = &#x27;MDragon&#x27;;\n      person.save(function(err){});\n    });\n</code></pre><p>这里，利用<code>Model</code>模型查询到了<code>person</code>对象，该对象属于<code>Entity</code>，可以有<code>save操作，如果使用</code>Model`操作，需注意：</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonModel.findById(id,function(err,person){\n      person.name = &#x27;MDragon&#x27;;\n      var _id = person._id; &#x2F;&#x2F;需要取出主键_id\n      delete person._id;    &#x2F;&#x2F;再将其删除\n      PersonModel.update({_id:_id},person,function(err){});\n      &#x2F;&#x2F;此时才能用Model操作，否则报错\n    });\n</code></pre><p><code>update</code>第一个参数是查询条件，第二个参数是更新的对象，但不能更新主键，这就是为什么要删除主键的原因。</p>\n<p>当然这样的更新很麻烦，可以使用<code>$set</code>属性来配置，这样也不用先查询，如果更新的数据比较少，可用性还是很好的：</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonModel.update({_id:_id},{$set:{name:&#x27;MDragon&#x27;}},function(err){});\n</code></pre><p>需要注意，<code>Document</code>的<code>CRUD</code>操作都是异步执行，<code>callback</code>第一个参数必须是<code>err</code>，而第二个参数各个方法不一样，<code>update</code>的<code>callback</code>第二个参数是更新的数量，如果要返回更新后的对象，则要使用如下方法</p>\n<pre class=\"prettyprint language-javascript\"><code>    Person.findByIdAndUpdate(_id,{$set:{name:&#x27;MDragon&#x27;}},function(err,person){\n      console.log(person.name); &#x2F;&#x2F;MDragon\n    });\n</code></pre><p>类似的方法还有<code>findByIdAndRemove</code>，如同名字，只能根据id查询并作<code>update</code>/<code>remove</code>操作，操作的数据仅一条</p>\n<p>####3.3 新增</p>\n<p>如果是<code>Entity</code>，使用<code>save</code>方法，如果是<code>Model</code>，使用<code>create</code>方法</p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F;使用Entity来增加一条数据\n    var krouky = new PersonModel({name:&#x27;krouky&#x27;});\n    krouky.save(callback);\n    &#x2F;&#x2F;使用Model来增加一条数据\n    var MDragon = {name:&#x27;MDragon&#x27;};\n    PersonModel.create(MDragon,callback);\n</code></pre><p>两种新增方法区别在于，如果使用<code>Model</code>新增时，传入的对象只能是纯净的<code>JSON</code>对象，不能是由<code>Model</code>创建的实体，原因是：由<code>Model</code>创建的实体<code>krouky</code>虽然打印是只有<code>{name:'krouky'}</code>，但是<code>krouky</code>属于<code>Entity</code>，包含有<code>Schema</code>属性和<code>Model</code>数据库行为模型。如果是使用<code>Model</code>创建的对象，传入时一定会将隐藏属性也存入数据库，虽然<code>3.x</code>追加了默认严格属性，但也不必要增加操作的报错</p>\n<p>####3.4 删除</p>\n<p>和新增一样，删除也有2种方式，但<code>Entity</code>和<code>Model</code>都使用<code>remove</code>方法</p>\n<p>###4.Sub Docs</p>\n<p>如同<code>SQL</code>数据库中2张表有主外关系，<code>Mongoose</code>将2个<code>Document</code>的嵌套叫做<code>Sub-Docs</code>（子文档）</p>\n<p>简单的说就是一个<code>Document</code>嵌套另外一个<code>Document</code>或者<code>Documents</code>:</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ChildSchema1 = new Schema({name:String});\n    var ChildSchema2 = new Schema({name:String});\n    var ParentSchema = new Schema({\n      children1:ChildSchema1,   &#x2F;&#x2F;嵌套Document\n      children2:[ChildSchema2]  &#x2F;&#x2F;嵌套Documents\n    });\n</code></pre><p><code>Sub-Docs</code>享受和<code>Documents</code>一样的操作，但是<code>Sub-Docs</code>的操作都由父类去执行</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ParentModel = db.model(&#x27;Parent&#x27;,parentSchema);\n    var parent = new ParentModel({\n      children2:[{name:&#x27;c1&#x27;},{name:&#x27;c2&#x27;}]\n    });\n    parent.children2[0].name = &#x27;d&#x27;;\n    parent.save(callback);\n</code></pre><p><code>parent</code>在执行保存时，由于包含<code>children2</code>，他是一个数据库模型对象，因此会先保存<code>chilren2[0]</code>和<code>chilren2[1]</code>。</p>\n<p>如果子文档在更新时出现错误，将直接报在父类文档中，可以这样处理：</p>\n<pre class=\"prettyprint language-javascript\"><code>    ChildrenSchema.pre(&#x27;save&#x27;,function(next){\n      if(&#x27;x&#x27; === this.name) return next(new Error(&#x27;#err:not-x&#x27;));\n      next();\n    });\n    var parent = new ParentModel({children1:{name:&#x27;not-x&#x27;}});\n    parent.save(function(err){\n      console.log(err.message); &#x2F;&#x2F;#err:not-x\n    });\n</code></pre><p>####4.1 查询子文档</p>\n<p>如果<code>children</code>是<code>parent</code>的子文档，可以通过如下方法查询到<code>children</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    var child = parent.children.id(id);\n</code></pre><p>####4.2 新增、删除、更新</p>\n<p>子文档是父文档的一个属性，因此按照属性的操作即可，不同的是在新增父类的时候，子文档是会被先加入进去的。</p>\n<p>如果<code>ChildrenSchema</code>是临时的一个子文档，不作为数据库映射集合，可以这样：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var ParentSchema = new Schema({\n      children:{\n        name:String\n      }\n    });\n    &#x2F;&#x2F;其实就是匿名混合模式\n</code></pre><p>###5.Model</p>\n<p>####5.1 什么是Model</p>\n<p><code>Model</code>模型，是经过<code>Schema</code>构造来的，除了<code>Schema</code>定义的数据库骨架以外，还具有数据库行为模型，他相当于管理数据库属性、行为的类</p>\n<p>####5.2 如何创建Model</p>\n<p>你必须通过<code>Schema</code>来创建，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F;先创建Schema\n    var TankSchema = new Schema({\n      name:&#x27;String&#x27;,\n      size:&#x27;String&#x27; \n    });\n    &#x2F;&#x2F;通过Schema创建Model\n    var TankModel = mongoose.model(&#x27;Tank&#x27;,TankSchema);\n</code></pre><p>####5.2 操作Model</p>\n<p>该模型就能直接拿来操作，具体查看<code>API</code>，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var tank = {&#x27;something&#x27;,size:&#x27;small&#x27;};\n    TankModel.create(tank);\n</code></pre><p><strong>注意：</strong></p>\n<p>你可以使用<code>Model</code>来创建<code>Entity</code>，<code>Entity</code>实体是一个特有<code>Model</code>具体对象，但是他并不具备<code>Model</code>的方法，只能用自己的方法。</p>\n<pre class=\"prettyprint language-javascript\"><code>  &#x2F;&#x2F;通过Model创建Entity\n  var tankEntity = new TankModel(&#x27;someother&#x27;,&#x27;size:big&#x27;);\n  tankEntity.save();\n</code></pre><p>###6.Query</p>\n<p>查询是数据库中运用最多也是最麻烦的地方，这里对<code>Query</code>解读的并不完善，仅仅是自己的一点领悟而已。</p>\n<p>####6.1 查询的方式</p>\n<p>通常有2种查询方式，一种是<code>直接查询</code>，一种是<code>链式查询</code>（2种查询都是自己命名的）</p>\n<p>#####6.1.1 直接查询</p>\n<p>在查询时带有回调函数的，称之为直接查询，查询的条件往往通过<code>API</code>来设定，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    PersonModel.findOne({&#x27;name.last&#x27;:&#x27;dragon&#x27;},&#x27;some select&#x27;,function(err,person){\n      &#x2F;&#x2F;如果err==null，则person就能取到数据\n    });\n</code></pre><p>具体的查询参数，请查询<code>API</code></p>\n<p>#####6.1.2 链式查询</p>\n<p>在查询时候，不带回调，而查询条件通过<code>API</code>函数来制定，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var query = PersonModel.findOne({&#x27;name.last&#x27;:&#x27;dragon&#x27;});\n    query.select(&#x27;some select&#x27;);\n    query.exec(function(err,pserson){\n    &#x2F;&#x2F;如果err==null，则person就能取到数据\n  });\n</code></pre><p>这种方式相对直接查询，分的比较明细，如果不带<code>callback</code>，则返回<code>query</code>，<code>query</code>没有执行的预编译查询语句，该<code>query</code>对象执行的方法都将返回自己，只有在执行<code>exec</code>方法时才执行查询，而且必须有回调。</p>\n<p>因为<code>query</code>的操作始终返回自身，我们可以采用更形象的链式写法</p>\n<pre class=\"prettyprint language-javascript\"><code>    Person\n      .find({ occupation: &#x2F;host&#x2F; })\n      .where(&#x27;name.last&#x27;).equals(&#x27;Ghost&#x27;)\n      .where(&#x27;age&#x27;).gt(17).lt(66)\n      .where(&#x27;likes&#x27;).in([&#x27;vaporizing&#x27;, &#x27;talking&#x27;])\n      .limit(10)\n      .sort(&#x27;-occupation&#x27;)\n      .select(&#x27;name occupation&#x27;)\n      .exec(callback);\n</code></pre><p>###7.Validation</p>\n<p>数据的存储是需要验证的，不是什么数据都能往数据库里丢或者显示到客户端的，数据的验证需要记住以下规则：</p>\n<ul>\n<li>验证始终定义在<code>SchemaType</code>中</li>\n<li>验证是一个内部中间件</li>\n<li>验证是在一个<code>Document</code>被保存时默认启用的，除非你关闭验证</li>\n<li>验证是异步递归的，如果你的<code>SubDoc</code>验证失败，<code>Document</code>也将无法保存</li>\n<li>验证并不关心错误类型，而通过<code>ValidationError</code>这个对象可以访问</li>\n</ul>\n<p>####7.1 验证器</p>\n<ol>\n<li><code>required</code> 非空验证</li>\n<li><code>min</code>/<code>max</code> 范围验证（边值验证）</li>\n<li><code>enum</code>/<code>match</code> 枚举验证/匹配验证</li>\n<li><code>validate</code> 自定义验证规则</li>\n</ol>\n<p>以下是综合案例：</p>\n<pre class=\"prettyprint language-javascript\"><code>    var PersonSchema = new Schema({\n      name:{\n        type:&#x27;String&#x27;,\n        required:true &#x2F;&#x2F;姓名非空\n      },\n      age:{\n        type:&#x27;Nunmer&#x27;,\n        min:18,       &#x2F;&#x2F;年龄最小18\n        max:120     &#x2F;&#x2F;年龄最大120\n      },\n      city:{\n        type:&#x27;String&#x27;,\n        enum:[&#x27;北京&#x27;,&#x27;上海&#x27;]  &#x2F;&#x2F;只能是北京、上海人\n      },\n      other:{\n        type:&#x27;String&#x27;,\n        validate:[validator,err]  &#x2F;&#x2F;validator是一个验证函数，err是验证失败的错误信息\n      }\n    });\n</code></pre><p>####7.2 验证失败</p>\n<p>如果验证失败，则会返回<code>err</code>信息，<code>err</code>是一个对象该对象属性如下</p>\n<pre class=\"prettyprint language-javascript\"><code>    err.errors                &#x2F;&#x2F;错误集合（对象）\n    err.errors.color          &#x2F;&#x2F;错误属性(Schema的color属性)\n    err.errors.color.message  &#x2F;&#x2F;错误属性信息\n    err.errors.path             &#x2F;&#x2F;错误属性路径\n    err.errors.type             &#x2F;&#x2F;错误类型\n    err.name                &#x2F;&#x2F;错误名称\n    err.message                 &#x2F;&#x2F;错误消息\n</code></pre><p>一旦验证失败，<code>Model</code>和<code>Entity</code>都将具有和<code>err</code>一样的<code>errors</code>属性</p>\n<p>###8.Middleware中间件</p>\n<p>####8.1 什么是中间件</p>\n<p>中间件是一种控制函数，类似插件，能控制流程中的<code>init</code>、validate<code>、</code>save<code>、</code>remove`方法</p>\n<p>####8.2 中间件的分类</p>\n<p>中间件分为两类</p>\n<p>#####8.2.1 Serial串行</p>\n<p>串行使用<code>pre</code>方法，执行下一个方法使用<code>next</code>调用</p>\n<pre class=\"prettyprint language-javascript\"><code>    var schema = new Schema(...);\n    schema.pre(&#x27;save&#x27;,function(next){\n      &#x2F;&#x2F;做点什么\n      next();\n    });\n</code></pre><p>#####8.2.2 Parallel并行</p>\n<p>并行提供更细粒度的操作</p>\n<pre class=\"prettyprint language-javascript\"><code>    var schema = new Schema(...);\n    schema.pre(&#x27;save&#x27;,function(next,done){\n      &#x2F;&#x2F;下一个要执行的中间件并行执行\n      next();\n      doAsync(done);\n    });\n</code></pre><p>####8.3 中间件特点</p>\n<p>一旦定义了中间件，就会在全部中间件执行完后执行其他操作，使用中间件可以雾化模型，避免异步操作的层层迭代嵌套</p>\n<p>####8.4 使用范畴</p>\n<ol>\n<li>复杂的验证</li>\n<li>删除有主外关联的<code>doc</code></li>\n<li>异步默认</li>\n<li>某个特定动作触发异步任务，例如触发自定义事件和通知</li>\n</ol>\n<p>例如，可以用来做自定义错误处理</p>\n<pre class=\"prettyprint language-javascript\"><code>    schema.pre(&#x27;save&#x27;,function(next){\n      var err = new Eerror(&#x27;some err&#x27;);\n      next(err);\n    });\n    entity.save(function(err){\n      console.log(err.message); &#x2F;&#x2F;some err\n    });\n</code></pre></div>",
		"title": "Mongoose学习参考文档——基础篇",
		"last_reply_at": "2017-03-31T09:46:54.597Z",
		"good": true,
		"top": false,
		"reply_count": 109,
		"visit_count": 163071,
		"create_at": "2012-09-08T13:33:24.577Z",
		"author": {
			"loginname": "a272121742",
			"avatar_url": "//gravatar.com/avatar/b087595f7b1a3801718f7a04d24add89?size=48"
		}
	}, {
		"id": "58c6d06e79f557ff16f0f2b8",
		"author_id": "503a6618f767cc9a5104139c",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"http://mditor.com/assets/site-shot.png\" alt=\"alt\"></p>\n<h1>简单说明</h1>\n<p>Mditor 最早只有「组件版」，随着「桌面版」的发布，Mditor 目前有两个版本：</p>\n<ul>\n<li>可嵌入到任意 Web 应用的 Embed 版本，这是一桌面版的基础，Repo: <a href=\"https://github.com/Houfeng/mditor\">https://github.com/houfeng/mditor</a></li>\n<li>独立的桌面版本，目前仅有 Mac 版本，主页：<a href=\"http://mditor.com\">http://mditor.com</a>，Repo: <a href=\"https://github.com/houfeng/mditor-desktop\">https://github.com/houfeng/mditor-desktop</a></li>\n</ul>\n<h1>相关特性</h1>\n<p>除常规的编辑功能，Mditor 桌面版还有如下特性</p>\n<ul>\n<li>多文件编辑，Mditor 桌面版是一个「多窗口」应用，可以通过「菜单、Dock、右键菜单」打开多个窗口实例进行多件编辑</li>\n<li>支持 GFM，如表格等（GFM 是 Github 拓展的基于 Markdown 的一种纯文本的书写格式）</li>\n<li>自动完成，Mditor 支持「无序列表、有序列表、引用」的自动完成，以辅助输入。</li>\n<li>多种编辑语言的的「代码高亮」支持（通过 ``` 语法）</li>\n<li>分屏实时预览，全屏预览</li>\n<li>导出 「HTML、PDF、Image」等功能。</li>\n</ul>\n<p><img src=\"http://mditor.com/assets/export-shot.png\" alt=\"alt\"></p>\n<h1>欢迎参与</h1>\n<ul>\n<li>如果有任何问题或建议，可以直接发起 <a href=\"https://github.com/Houfeng/mditor-desktop/issues\">Issue</a></li>\n<li>当然，你也可以直接向 Mditor 发起 <a href=\"https://github.com/Houfeng/mditor-desktop/pulls\">Pull Request</a></li>\n<li>非常欢迎，直接给 Mditor <a href=\"https://github.com/houfeng/mditor-desktop\">加个 Star</a>，这将是对 Midior 不错的鼓励，它会变成动力。</li>\n</ul>\n<h1>后续规划</h1>\n<ul>\n<li>多语言支持</li>\n<li>流程图、数学公式支持</li>\n</ul>\n<h1>相关贴子</h1>\n<ul>\n<li><a href=\"http://cnodejs.org/topic/58baccc25b904b25651b3b9f\">Mditor 更新啦</a></li>\n<li><a href=\"http://cnodejs.org/topic/5617b3b7efc7a0bd4fb338ce\">分享一个 markdown 编辑器 - Mditor</a></li>\n</ul>\n</div>",
		"title": "分享开源 Markdown 编辑器 Mditor 的「桌面版」",
		"last_reply_at": "2017-03-31T09:40:26.678Z",
		"good": false,
		"top": false,
		"reply_count": 10,
		"visit_count": 1665,
		"create_at": "2017-03-13T17:01:34.524Z",
		"author": {
			"loginname": "houfeng",
			"avatar_url": "//gravatar.com/avatar/4ccd30a6ccc36203b826a50047183ea6?size=48"
		}
	}]
}