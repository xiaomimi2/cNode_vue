##数组的结构赋值
<script type="text/javascript">
    let [a, b, c] = [1, 2, 3]
    let [, , third] = ['foo', 'baz', 'bar']
    console.log(third)// 'bar'

    let[head,  ...tail] = [1, 2, 3, 4]
    console.log(tail) // [2, 3, 4]

    let[x, y, ...z] = ['a']
    console.log(z) //[]
</script>

如果解构不成功，值都会是undefined
<script type="text/javascript">
    let [bar, foo] = [1]
    console.log(bar)//1
    console.log(foo)//undefined
    let [a, [b], c] = [1, [2, 3], 4]
    console.log(b) // 2
</script>

解构赋值允许指定默认值
<script type="text/javascript">
    let [foo = true] = []
    console.log(foo)//true 
</script>

ES6内部严格使用相等运算符。判断一个位置是否有值，所以如果一个数组成员不严格等于undefined，默认值是不会生效的。
<script type="text/javascript">
    let [x = 1] = [undefined]
    console.log(x) //1

    let [x = 1] = [null]
    console.log(x)//null
</script>


如果默认值是一个表达式。那么这个表达式式惰性求值的。
<script type="text/javascript">
    function f() {
        console.log('aaa')
    }
    let [x = f()] = [1]//这里函数根本不会执行，因为不是undefined
    console.log(x) //1
</script>

默认值可以引用结构赋值的其他变量，但变量必须已经声明
<script type="text/javascript">
    let [x = 1, y = x] = [2] //x = 2, y = 2
    let [x = 1, y = x] = [1, 2]// x = 1, y = 2
    let [x = y, y = 1] = []  //ReferenceError
</script>




##对象的结构赋值
<script type="text/javascript">
    let {foo, bar} = {foo: 'aaa', bar: 'bbb'} //foo 'aaa', bar 'bbb'
    let {baz} = {foo: 'aaa', bar: 'bbb'}//baz undefined  必须是写成同名属性
</script>

如果变量名和属性名不一致，必须写成下面的
<script type="text/javascript">
    var {foo: baz} = {foo: 'aaa', bar: 'bbb'} //baz 'aaa'
    console.log(foo) //error foo is not defined 
</script>